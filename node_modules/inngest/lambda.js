"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serve = exports.name = void 0;
const InngestCommHandler_1 = require("./components/InngestCommHandler");
const consts_1 = require("./helpers/consts");
exports.name = "aws-lambda";
/**
 * With AWS Lambda, serve and register any declared functions with Inngest,
 * making them available to be triggered by events.
 *
 * @example
 *
 * ```ts
 * import { Inngest } from "inngest";
 * import { serve } from "inngest/lambda";
 *
 * const inngest = new Inngest({ name: "My Lambda App" });
 *
 * const fn = inngest.createFunction(
 *   { name: "Hello World" },
 *   { event: "test/hello.world" },
 *   async ({ event }) => {
 *     return "Hello World";
 *   }
 * );
 *
 * export const handler = serve(inngest, [fn]);
 * ```
 *
 * @public
 */
const serve = (nameOrInngest, fns, opts) => {
    const handler = new InngestCommHandler_1.InngestCommHandler(exports.name, nameOrInngest, fns, Object.assign({}, opts), (event, _context) => {
        /**
         * Try to handle multiple incoming event types, as Lambda can have many
         * triggers.
         *
         * This still doesn't handle all cases, but it's a start.
         */
        const eventIsV2 = ((ev) => {
            return ev.version === "2.0";
        })(event);
        const method = eventIsV2
            ? event.requestContext.http.method
            : event.httpMethod;
        const path = eventIsV2 ? event.requestContext.http.path : event.path;
        let url;
        try {
            const proto = event.headers["x-forwarded-proto"] || "https";
            url = new URL(path, `${proto}://${event.headers.host || ""}`);
        }
        catch (err) {
            // TODO PrettyError
            throw new Error("Could not parse URL from `event.headers.host`");
        }
        return {
            url,
            register: () => {
                var _a;
                if (method === "PUT") {
                    return {
                        deployId: (_a = event.queryStringParameters) === null || _a === void 0 ? void 0 : _a[consts_1.queryKeys.DeployId],
                    };
                }
            },
            run: () => {
                var _a, _b;
                if (method === "POST") {
                    return {
                        data: JSON.parse(event.body
                            ? event.isBase64Encoded
                                ? Buffer.from(event.body, "base64").toString()
                                : event.body
                            : "{}"),
                        fnId: (_a = event.queryStringParameters) === null || _a === void 0 ? void 0 : _a[consts_1.queryKeys.FnId],
                        stepId: (_b = event.queryStringParameters) === null || _b === void 0 ? void 0 : _b[consts_1.queryKeys.StepId],
                        signature: event.headers[consts_1.headerKeys.Signature],
                    };
                }
            },
            view: () => {
                if (method === "GET") {
                    return {
                        isIntrospection: Object.hasOwnProperty.call(event.queryStringParameters || {}, consts_1.queryKeys.Introspect),
                    };
                }
            },
        };
    }, ({ body, status, headers }) => {
        return Promise.resolve({
            body,
            statusCode: status,
            headers,
        });
    });
    return handler.createHandler();
};
exports.serve = serve;
//# sourceMappingURL=lambda.js.map