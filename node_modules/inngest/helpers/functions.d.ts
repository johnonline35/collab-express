import { type Await } from "./types";
/**
 * Wraps a function with a cache. When the returned function is run, it will
 * cache the result and return it on subsequent calls.
 */
export declare const cacheFn: <T extends (...args: unknown[]) => unknown>(fn: T) => T;
/**
 * Given an array of functions, return a new function that will run each
 * function in series and return the result of the final function. Regardless of
 * if the functions are synchronous or asynchronous, they'll be made into an
 * async promise chain.
 *
 * If an error is thrown, the waterfall will stop and return the error.
 *
 * Because this needs to support both sync and async functions, it only allows
 * functions that accept a single argument.
 *
 * TODO Add a second function that decides how to merge results from prev and current results.
 */
export declare const waterfall: <TFns extends ((arg?: any) => any)[]>(fns: TFns, transform?: ((prev: any, output: any) => any) | undefined) => (...args: Parameters<TFns[number]>) => Promise<Await<TFns[number]>>;
//# sourceMappingURL=functions.d.ts.map