"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ServerTiming_timings;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerTiming = void 0;
/**
 * A class to manage timing functions and arbitrary periods of time before
 * generating a `Server-Timing` header for use in HTTP responses.
 *
 * This is a very simple implementation that does not support nested timings or
 * fractions of a millisecond.
 */
class ServerTiming {
    constructor() {
        _ServerTiming_timings.set(this, {});
    }
    /**
     * Start a timing. Returns a function that, when called, will stop the timing
     * and add it to the header.
     */
    start(name, description) {
        if (!__classPrivateFieldGet(this, _ServerTiming_timings, "f")[name]) {
            __classPrivateFieldGet(this, _ServerTiming_timings, "f")[name] = {
                description: description !== null && description !== void 0 ? description : "",
                timers: [],
            };
        }
        const index = __classPrivateFieldGet(this, _ServerTiming_timings, "f")[name].timers.push({ start: Date.now() }) - 1;
        return () => {
            const target = __classPrivateFieldGet(this, _ServerTiming_timings, "f")[name];
            if (!target) {
                return console.warn(`Timing "${name}" does not exist`);
            }
            const timer = target.timers[index];
            if (!timer) {
                return console.warn(`Timer ${index} for timing "${name}" does not exist`);
            }
            timer.end = Date.now();
        };
    }
    /**
     * Add a piece of arbitrary, untimed information to the header. Common use
     * cases would be cache misses.
     *
     * @example
     * ```
     * timer.append("cache", "miss");
     * ```
     */
    append(key, value) {
        __classPrivateFieldGet(this, _ServerTiming_timings, "f")[key] = {
            description: value,
            timers: [],
        };
    }
    /**
     * Wrap a function in a timing. The timing will be stopped and added to the
     * header when the function resolves or rejects.
     *
     * The return value of the function will be returned from this function.
     */
    async wrap(name, fn, description) {
        const stop = this.start(name, description);
        try {
            return (await Promise.resolve(fn()));
        }
        finally {
            stop();
        }
    }
    /**
     * Generate the `Server-Timing` header.
     */
    getHeader() {
        const entries = Object.entries(__classPrivateFieldGet(this, _ServerTiming_timings, "f")).reduce((acc, [name, { description, timers }]) => {
            /**
             * Ignore timers that had no end.
             */
            const hasTimersWithEnd = timers.some((timer) => timer.end);
            if (!hasTimersWithEnd) {
                return acc;
            }
            const dur = timers.reduce((acc, { start, end }) => {
                if (!start || !end)
                    return acc;
                return acc + (end - start);
            }, 0);
            const entry = [
                name,
                description ? `desc="${description}"` : "",
                dur ? `dur=${dur}` : "",
            ]
                .filter(Boolean)
                .join(";");
            return [...acc, entry];
        }, []);
        return entries.join(", ");
    }
}
exports.ServerTiming = ServerTiming;
_ServerTiming_timings = new WeakMap();
//# sourceMappingURL=ServerTiming.js.map