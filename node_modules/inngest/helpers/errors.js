"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OutgoingResultError = exports.fixEventKeyMissingSteps = exports.functionStoppedRunningErr = exports.prettyError = exports.ErrCode = exports.deserializeError = exports.isSerializedError = exports.serializeError = void 0;
const chalk_1 = __importDefault(require("chalk"));
const serialize_error_cjs_1 = require("serialize-error-cjs");
const SERIALIZED_KEY = "__serialized";
const SERIALIZED_VALUE = true;
/**
 * Serialise an error to a plain object.
 *
 * Errors do not serialise nicely to JSON, so we use this function to convert
 * them to a plain object. Doing this is also non-trivial for some errors, so
 * we use the `serialize-error` package to do it for us.
 *
 * See {@link https://www.npmjs.com/package/serialize-error}
 *
 * This function is a small wrapper around that package to also add a `type`
 * property to the serialised error, so that we can distinguish between
 * serialised errors and other objects.
 *
 * Will not reserialise existing serialised errors.
 */
const serializeError = (subject) => {
    if ((0, exports.isSerializedError)(subject)) {
        return subject;
    }
    return Object.assign(Object.assign({}, (0, serialize_error_cjs_1.serializeError)(subject)), { [SERIALIZED_KEY]: SERIALIZED_VALUE });
};
exports.serializeError = serializeError;
/**
 * Check if an object is a serialised error created by {@link serializeError}.
 */
const isSerializedError = (value) => {
    try {
        return (Object.prototype.hasOwnProperty.call(value, SERIALIZED_KEY) &&
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            value[SERIALIZED_KEY] ===
                SERIALIZED_VALUE);
    }
    catch (_a) {
        return false;
    }
};
exports.isSerializedError = isSerializedError;
/**
 * Deserialise an error created by {@link serializeError}.
 *
 * Ensures we only deserialise errors that meet a minimum level of
 * applicability, inclusive of error handling to ensure that badly serialized
 * errors are still handled.
 */
const deserializeError = (subject) => {
    const requiredFields = ["name", "message"];
    try {
        const hasRequiredFields = requiredFields.every((field) => {
            return Object.prototype.hasOwnProperty.call(subject, field);
        });
        if (!hasRequiredFields) {
            throw new Error();
        }
        return (0, serialize_error_cjs_1.deserializeError)(subject);
    }
    catch (_a) {
        const err = new Error("Unknown error; could not reserialize");
        /**
         * Remove the stack so that it's not misleadingly shown as the Inngest
         * internals.
         */
        err.stack = undefined;
        return err;
    }
};
exports.deserializeError = deserializeError;
var ErrCode;
(function (ErrCode) {
    ErrCode["ASYNC_DETECTED_DURING_MEMOIZATION"] = "ASYNC_DETECTED_DURING_MEMOIZATION";
    ErrCode["ASYNC_DETECTED_AFTER_MEMOIZATION"] = "ASYNC_DETECTED_AFTER_MEMOIZATION";
    ErrCode["STEP_USED_AFTER_ASYNC"] = "STEP_USED_AFTER_ASYNC";
    ErrCode["NESTING_STEPS"] = "NESTING_STEPS";
})(ErrCode = exports.ErrCode || (exports.ErrCode = {}));
/**
 * Given a {@link PrettyError}, return a nicely-formatted string ready to log
 * or throw.
 *
 * Useful for ensuring that errors are logged in a consistent, helpful format
 * across the SDK by prompting for key pieces of information.
 */
const prettyError = ({ type = "error", whatHappened, otherwise, reassurance, toFixNow, why, consequences, stack, code, }) => {
    var _a, _b;
    const { icon, colorFn } = ({
        error: { icon: "❌", colorFn: chalk_1.default.red },
        warn: { icon: "⚠️", colorFn: chalk_1.default.yellow },
    })[type];
    const splitter = "=================================================";
    let header = `${icon}  ${chalk_1.default.bold.underline(whatHappened.trim())}`;
    if (stack) {
        header +=
            "\n" +
                [...(((_a = new Error().stack) === null || _a === void 0 ? void 0 : _a.split("\n").slice(1).filter(Boolean)) || [])].join("\n");
    }
    let toFixNowStr = (_b = (Array.isArray(toFixNow)
        ? toFixNow
            .map((s) => s.trim())
            .filter(Boolean)
            .map((s, i) => `\t${i + 1}. ${s}`)
            .join("\n")
        : toFixNow === null || toFixNow === void 0 ? void 0 : toFixNow.trim())) !== null && _b !== void 0 ? _b : "";
    if (Array.isArray(toFixNow) && toFixNowStr) {
        toFixNowStr = `To fix this, you can take one of the following courses of action:\n\n${toFixNowStr}`;
    }
    let body = [reassurance === null || reassurance === void 0 ? void 0 : reassurance.trim(), why === null || why === void 0 ? void 0 : why.trim(), consequences === null || consequences === void 0 ? void 0 : consequences.trim()]
        .filter(Boolean)
        .join(" ");
    body += body ? `\n\n${toFixNowStr}` : toFixNowStr;
    const trailer = [otherwise === null || otherwise === void 0 ? void 0 : otherwise.trim()].filter(Boolean).join(" ");
    const message = [
        splitter,
        header,
        body,
        trailer,
        code ? `Code: ${code}` : "",
        splitter,
    ]
        .filter(Boolean)
        .join("\n\n");
    return colorFn(message);
};
exports.prettyError = prettyError;
const functionStoppedRunningErr = (code) => {
    return (0, exports.prettyError)({
        whatHappened: "Your function was stopped from running",
        why: "We detected a mix of asynchronous logic, some using step tooling and some not.",
        consequences: "This can cause unexpected behaviour when a function is paused and resumed and is therefore strongly discouraged; we stopped your function to ensure nothing unexpected happened!",
        stack: true,
        toFixNow: "Ensure that your function is either entirely step-based or entirely non-step-based, by either wrapping all asynchronous logic in `step.run()` calls or by removing all `step.*()` calls.",
        otherwise: "For more information on why step functions work in this manner, see https://www.inngest.com/docs/functions/multi-step#gotchas",
        code,
    });
};
exports.functionStoppedRunningErr = functionStoppedRunningErr;
exports.fixEventKeyMissingSteps = [
    "Set the `INNGEST_EVENT_KEY` environment variable",
    `Pass a key to the \`new Inngest()\` constructor using the \`${"eventKey"}\` option`,
    `Use \`inngest.${"setEventKey"}()\` at runtime`,
];
/**
 * An error that, when thrown, indicates internally that an outgoing operation
 * contains an error.
 *
 * We use this because serialized `data` sent back to Inngest may differ from
 * the error instance itself due to middleware.
 *
 * @internal
 */
class OutgoingResultError extends Error {
    constructor(result) {
        super("OutgoingOpError");
        this.result = result;
    }
}
exports.OutgoingResultError = OutgoingResultError;
//# sourceMappingURL=errors.js.map