import { type Inngest } from "../components/Inngest";
import { type SupportedFrameworkName } from "../types";
/**
 * devServerHost returns the dev server host by searching for the INNGEST_DEVSERVER_URL
 * environment variable (plus project prefixces for eg. react, such as REACT_APP_INNGEST_DEVSERVER_URL).
 *
 * If not found this returns undefined, indicating that the env var has not been set.
 *
 * @example devServerHost()
 */
export declare const devServerHost: () => string | undefined;
/**
 * Returns `true` if we're running in production or on a platform, based off of
 * either passed environment variables or `process.env`.
 */
export declare const skipDevServer: (env?: Record<string, unknown>) => boolean;
/**
 * Returns `true` if we believe the current environment is production based on
 * either passed environment variables or `process.env`.
 */
export declare const isProd: (env?: Record<string, unknown>) => boolean;
/**
 * getEnvironmentName returns the suspected branch name for this environment by
 * searching through a set of common environment variables.
 *
 * This could be used to determine if we're on a branch deploy or not, though it
 * should be noted that we don't know if this is the default branch or not.
 */
export declare const getEnvironmentName: (env?: Record<string, string | undefined>) => string | undefined;
export declare const processEnv: (key: string) => string | undefined;
/**
 * allProcessEnv returns the current process environment variables, or an empty
 * object if they cannot be read, making sure we support environments other than
 * Node such as Deno, too.
 *
 * Using this ensures we don't dangerously access `process.env` in environments
 * where it may not be defined, such as Deno or the browser.
 */
export declare const allProcessEnv: () => Record<string, string | undefined>;
/**
 * Generate a standardised set of headers based on input and environment
 * variables.
 *
 *
 */
export declare const inngestHeaders: (opts?: {
    /**
     * The environment variables to use instead of `process.env` or any other
     * default source. Useful for platforms where environment variables are passed
     * in alongside requests.
     */
    env?: Record<string, string | undefined>;
    /**
     * The framework name to use in the `X-Inngest-Framework` header. This is not
     * always available, hence being optional.
     */
    framework?: string;
    /**
     * The environment name to use in the `X-Inngest-Env` header. This is likely
     * to be representative of the target preview environment.
     */
    inngestEnv?: string;
    /**
     * The Inngest client that's making the request. The client itself will
     * generate a set of headers; specifying it here will ensure that the client's
     * headers are included in the returned headers.
     */
    client?: Inngest;
    /**
     * Any additional headers to include in the returned headers.
     */
    extras?: Record<string, string>;
}) => Record<string, string>;
/**
 * Returns `true` if we believe the current environment supports streaming
 * responses back to Inngest.
 *
 * We run a check directly related to the platform we believe we're running on,
 * usually based on environment variables.
 */
export declare const platformSupportsStreaming: (framework: SupportedFrameworkName, env?: Record<string, string | undefined>) => boolean;
/**
 * Given a potential fetch function, return the fetch function to use based on
 * this and the environment.
 */
export declare const getFetch: (givenFetch?: typeof fetch) => typeof fetch;
//# sourceMappingURL=env.d.ts.map