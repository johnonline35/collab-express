"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waterfall = exports.cacheFn = void 0;
/**
 * Wraps a function with a cache. When the returned function is run, it will
 * cache the result and return it on subsequent calls.
 */
const cacheFn = (fn) => {
    const key = "value";
    const cache = new Map();
    return ((...args) => {
        if (!cache.has(key)) {
            cache.set(key, fn(...args));
        }
        return cache.get(key);
    });
};
exports.cacheFn = cacheFn;
/**
 * Given an array of functions, return a new function that will run each
 * function in series and return the result of the final function. Regardless of
 * if the functions are synchronous or asynchronous, they'll be made into an
 * async promise chain.
 *
 * If an error is thrown, the waterfall will stop and return the error.
 *
 * Because this needs to support both sync and async functions, it only allows
 * functions that accept a single argument.
 *
 * TODO Add a second function that decides how to merge results from prev and current results.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const waterfall = (fns, 
/**
 * A function that transforms the result of each function in the waterfall,
 * ready for the next function.
 *
 * Will not be called on the final function.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
transform) => {
    return (...args) => {
        const chain = fns.reduce(async (acc, fn) => {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            const prev = await acc;
            const output = (await fn(prev));
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return transform ? await transform(prev, output) : output;
        }, Promise.resolve(args[0]));
        return chain;
    };
};
exports.waterfall = waterfall;
//# sourceMappingURL=functions.js.map