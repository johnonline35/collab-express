"use strict";
// This file exists to help normalize process.env amongst the backend
// and frontend.  Many frontends (eg. Next, CRA) utilize webpack's DefinePlugin
// along with prefixes, meaning we have to explicitly use the full `process.env.FOO`
// string in order to read variables.
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFetch = exports.platformSupportsStreaming = exports.inngestHeaders = exports.allProcessEnv = exports.processEnv = exports.getEnvironmentName = exports.isProd = exports.skipDevServer = exports.devServerHost = void 0;
const version_1 = require("../version");
const consts_1 = require("./consts");
const strings_1 = require("./strings");
/**
 * devServerHost returns the dev server host by searching for the INNGEST_DEVSERVER_URL
 * environment variable (plus project prefixces for eg. react, such as REACT_APP_INNGEST_DEVSERVER_URL).
 *
 * If not found this returns undefined, indicating that the env var has not been set.
 *
 * @example devServerHost()
 */
const devServerHost = () => {
    // devServerKeys are the env keys we search for to discover the dev server
    // URL.  This includes the standard key first, then includes prefixed keys
    // for use within common frameworks (eg. CRA, next).
    //
    // We have to fully write these using process.env as they're typically
    // processed using webpack's DefinePlugin, which is dumb and does a straight
    // text replacement instead of actually understanding the AST, despite webpack
    // being fully capable of understanding the AST.
    const values = [
        (0, exports.processEnv)(consts_1.envKeys.DevServerUrl),
        (0, exports.processEnv)("REACT_APP_INNGEST_DEVSERVER_URL"),
        (0, exports.processEnv)("NEXT_PUBLIC_INNGEST_DEVSERVER_URL"),
    ];
    return values.find((a) => !!a);
};
exports.devServerHost = devServerHost;
const checkFns = ((checks) => checks)({
    equals: (actual, expected) => actual === expected,
    "starts with": (actual, expected) => { var _a; return expected ? (_a = actual === null || actual === void 0 ? void 0 : actual.startsWith(expected)) !== null && _a !== void 0 ? _a : false : false; },
    "is truthy": (actual) => Boolean(actual),
    "is truthy but not": (actual, expected) => Boolean(actual) && actual !== expected,
});
const prodChecks = [
    ["CF_PAGES", "equals", "1"],
    ["CONTEXT", "starts with", "prod"],
    ["ENVIRONMENT", "starts with", "prod"],
    ["NODE_ENV", "starts with", "prod"],
    ["VERCEL_ENV", "starts with", "prod"],
    ["DENO_DEPLOYMENT_ID", "is truthy"],
];
// platformDeployChecks are a series of predicates that attempt to check whether
// we're deployed outside of localhost testing.  This extends prodChecks with
// platform specific checks, ensuring that if you deploy to eg. vercel without
// NODE_ENV=production we still use prod mode.
const platformDeployChecks = [
    // Extend prod checks, then check if we're deployed to a platform.
    [consts_1.prodEnvKeys.VercelEnvKey, "is truthy but not", "development"],
    [consts_1.envKeys.IsNetlify, "is truthy"],
    [consts_1.envKeys.IsRender, "is truthy"],
    [consts_1.envKeys.RailwayBranch, "is truthy"],
    [consts_1.envKeys.IsCloudflarePages, "is truthy"],
];
const skipDevServerChecks = prodChecks.concat(platformDeployChecks);
/**
 * Returns `true` if we're running in production or on a platform, based off of
 * either passed environment variables or `process.env`.
 */
const skipDevServer = (
/**
 * The optional environment variables to use instead of `process.env`.
 */
env = (0, exports.allProcessEnv)()) => {
    return skipDevServerChecks.some(([key, checkKey, expected]) => {
        return checkFns[checkKey]((0, strings_1.stringifyUnknown)(env[key]), expected);
    });
};
exports.skipDevServer = skipDevServer;
/**
 * Returns `true` if we believe the current environment is production based on
 * either passed environment variables or `process.env`.
 */
const isProd = (
/**
 * The optional environment variables to use instead of `process.env`.
 */
env = (0, exports.allProcessEnv)()) => {
    return prodChecks.some(([key, checkKey, expected]) => {
        return checkFns[checkKey]((0, strings_1.stringifyUnknown)(env[key]), expected);
    });
};
exports.isProd = isProd;
/**
 * getEnvironmentName returns the suspected branch name for this environment by
 * searching through a set of common environment variables.
 *
 * This could be used to determine if we're on a branch deploy or not, though it
 * should be noted that we don't know if this is the default branch or not.
 */
const getEnvironmentName = (env = (0, exports.allProcessEnv)()) => {
    /**
     * Order is important; more than one of these env vars may be set, so ensure
     * that we check the most specific, most reliable env vars first.
     */
    return (env[consts_1.envKeys.Environment] ||
        env[consts_1.envKeys.BranchName] ||
        env[consts_1.envKeys.VercelBranch] ||
        env[consts_1.envKeys.NetlifyBranch] ||
        env[consts_1.envKeys.CloudflarePagesBranch] ||
        env[consts_1.envKeys.RenderBranch] ||
        env[consts_1.envKeys.RailwayBranch]);
};
exports.getEnvironmentName = getEnvironmentName;
const processEnv = (key) => {
    return (0, exports.allProcessEnv)()[key];
};
exports.processEnv = processEnv;
/**
 * allProcessEnv returns the current process environment variables, or an empty
 * object if they cannot be read, making sure we support environments other than
 * Node such as Deno, too.
 *
 * Using this ensures we don't dangerously access `process.env` in environments
 * where it may not be defined, such as Deno or the browser.
 */
const allProcessEnv = () => {
    try {
        // eslint-disable-next-line @inngest/process-warn
        if (process.env) {
            // eslint-disable-next-line @inngest/process-warn
            return process.env;
        }
    }
    catch (_err) {
        // noop
    }
    try {
        const env = Deno.env.toObject();
        if (env) {
            return env;
        }
    }
    catch (_err) {
        // noop
    }
    return {};
};
exports.allProcessEnv = allProcessEnv;
/**
 * Generate a standardised set of headers based on input and environment
 * variables.
 *
 *
 */
const inngestHeaders = (opts) => {
    var _a;
    const sdkVersion = `inngest-js:v${version_1.version}`;
    const headers = {
        "Content-Type": "application/json",
        "User-Agent": sdkVersion,
        [consts_1.headerKeys.SdkVersion]: sdkVersion,
    };
    if (opts === null || opts === void 0 ? void 0 : opts.framework) {
        headers[consts_1.headerKeys.Framework] = opts.framework;
    }
    const env = Object.assign(Object.assign({}, (0, exports.allProcessEnv)()), opts === null || opts === void 0 ? void 0 : opts.env);
    const inngestEnv = (opts === null || opts === void 0 ? void 0 : opts.inngestEnv) || (0, exports.getEnvironmentName)(env);
    if (inngestEnv) {
        headers[consts_1.headerKeys.Environment] = inngestEnv;
    }
    const platform = getPlatformName(env);
    if (platform) {
        headers[consts_1.headerKeys.Platform] = platform;
    }
    return Object.assign(Object.assign(Object.assign({}, headers), (_a = opts === null || opts === void 0 ? void 0 : opts.client) === null || _a === void 0 ? void 0 : _a["headers"]), opts === null || opts === void 0 ? void 0 : opts.extras);
};
exports.inngestHeaders = inngestHeaders;
/**
 * A set of checks that, given an environment, will return `true` if the current
 * environment is running on the platform with the given name.
 */
const platformChecks = {
    /**
     * Vercel Edge Functions don't have access to environment variables unless
     * they are explicitly referenced in the top level code, but they do have a
     * global `EdgeRuntime` variable set that we can use to detect this.
     */
    vercel: (env) => env[consts_1.envKeys.IsVercel] === "1" || typeof EdgeRuntime === "string",
    netlify: (env) => env[consts_1.envKeys.IsNetlify] === "true",
    "cloudflare-pages": (env) => env[consts_1.envKeys.IsCloudflarePages] === "1",
    render: (env) => env[consts_1.envKeys.IsRender] === "true",
    railway: (env) => Boolean(env[consts_1.envKeys.RailwayEnvironment]),
};
/**
 * A set of checks that, given an environment, will return `true` if the current
 * environment and platform supports streaming responses back to Inngest.
 *
 * Streaming capability is both framework and platform-based. Frameworks are
 * supported in serve handlers, and platforms are checked here.
 *
 * As such, this record declares which platforms we explicitly support for
 * streaming and is used by {@link platformSupportsStreaming}.
 */
const streamingChecks = {
    /**
     * "Vercel supports streaming for Serverless Functions, Edge Functions, and
     * React Server Components in Next.js projects."
     *
     * In practice, however, there are many reports of streaming not working as
     * expected on Serverless Functions, so we resort to only allowing streaming
     * for Edge Functions here.
     *
     * See {@link https://vercel.com/docs/frameworks/nextjs#streaming}
     */
    vercel: (_framework, _env) => typeof EdgeRuntime === "string",
};
const getPlatformName = (env) => {
    return Object.keys(platformChecks).find((key) => {
        return platformChecks[key](env);
    });
};
/**
 * Returns `true` if we believe the current environment supports streaming
 * responses back to Inngest.
 *
 * We run a check directly related to the platform we believe we're running on,
 * usually based on environment variables.
 */
const platformSupportsStreaming = (framework, env = (0, exports.allProcessEnv)()) => {
    var _a, _b;
    return ((_b = (_a = streamingChecks[getPlatformName(env)]) === null || _a === void 0 ? void 0 : _a.call(streamingChecks, framework, env)) !== null && _b !== void 0 ? _b : false);
};
exports.platformSupportsStreaming = platformSupportsStreaming;
/**
 * Given a potential fetch function, return the fetch function to use based on
 * this and the environment.
 */
const getFetch = (givenFetch) => {
    if (givenFetch) {
        return givenFetch;
    }
    /**
     * Browser or Node 18+
     */
    try {
        if (typeof globalThis !== "undefined" && "fetch" in globalThis) {
            return fetch.bind(globalThis);
        }
    }
    catch (err) {
        // no-op
    }
    /**
     * Existing polyfilled fetch
     */
    if (typeof fetch !== "undefined") {
        return fetch;
    }
    /**
     * Environments where fetch cannot be found and must be polyfilled
     */
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    return require("cross-fetch");
};
exports.getFetch = getFetch;
//# sourceMappingURL=env.js.map