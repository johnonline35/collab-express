import { type OutgoingOp } from "../types";
declare const SERIALIZED_KEY = "__serialized";
declare const SERIALIZED_VALUE = true;
export interface SerializedError {
    readonly [SERIALIZED_KEY]: typeof SERIALIZED_VALUE;
    readonly name: string;
    readonly message: string;
    readonly stack: string;
}
/**
 * Serialise an error to a plain object.
 *
 * Errors do not serialise nicely to JSON, so we use this function to convert
 * them to a plain object. Doing this is also non-trivial for some errors, so
 * we use the `serialize-error` package to do it for us.
 *
 * See {@link https://www.npmjs.com/package/serialize-error}
 *
 * This function is a small wrapper around that package to also add a `type`
 * property to the serialised error, so that we can distinguish between
 * serialised errors and other objects.
 *
 * Will not reserialise existing serialised errors.
 */
export declare const serializeError: (subject: unknown) => SerializedError;
/**
 * Check if an object is a serialised error created by {@link serializeError}.
 */
export declare const isSerializedError: (value: unknown) => boolean;
/**
 * Deserialise an error created by {@link serializeError}.
 *
 * Ensures we only deserialise errors that meet a minimum level of
 * applicability, inclusive of error handling to ensure that badly serialized
 * errors are still handled.
 */
export declare const deserializeError: (subject: Partial<SerializedError>) => Error;
export declare enum ErrCode {
    ASYNC_DETECTED_DURING_MEMOIZATION = "ASYNC_DETECTED_DURING_MEMOIZATION",
    ASYNC_DETECTED_AFTER_MEMOIZATION = "ASYNC_DETECTED_AFTER_MEMOIZATION",
    STEP_USED_AFTER_ASYNC = "STEP_USED_AFTER_ASYNC",
    NESTING_STEPS = "NESTING_STEPS"
}
export interface PrettyError {
    /**
     * The type of message, used to decide on icon and color use.
     */
    type?: "error" | "warn";
    /**
     * A short, succinct description of what happened. Will be used as the error's
     * header, so should be short and to the point with no trailing punctuation.
     */
    whatHappened: string;
    /**
     * If applicable, provide a full sentence to reassure the user about certain
     * details, for example if an error occurred whilst uploading a file, but we
     * can assure the user that uploading succeeded and something internal failed.
     */
    reassurance?: string;
    /**
     * Tell the user why the error happened if we can. This should be a full
     * sentence or paragraph that explains the error in more detail, for example
     * to explain that a file failed to upload because it was too large and that
     * the maximum size is 10MB.
     */
    why?: string;
    /**
     * If applicable, tell the user what the consequences of the error are, for
     * example to tell them that their file was not uploaded and that they will
     * need to try again.
     */
    consequences?: string;
    /**
     * If we can, tell the user what they can do to fix the error now. This should
     * be a full sentence or paragraph that explains what the user can do to fix
     * the error, for example to tell them to try uploading a smaller file or
     * upgrade to a paid plan.
     */
    toFixNow?: string | string[];
    /**
     * If applicable, tell the user what to do if the error persists, they want
     * more information, or the fix we've given them doesn't work.
     *
     * This should be a full sentence or paragraph, and will likely refer users
     * to contact us for support, join our Discord, or read documentation.
     */
    otherwise?: string;
    /**
     * Add a stack trace to the message so that the user knows what line of code
     * the error is in relation to.
     */
    stack?: true;
    /**
     * If applicable, provide a code that the user can use to reference the error
     * when contacting support.
     */
    code?: ErrCode;
}
/**
 * Given a {@link PrettyError}, return a nicely-formatted string ready to log
 * or throw.
 *
 * Useful for ensuring that errors are logged in a consistent, helpful format
 * across the SDK by prompting for key pieces of information.
 */
export declare const prettyError: ({ type, whatHappened, otherwise, reassurance, toFixNow, why, consequences, stack, code, }: PrettyError) => string;
export declare const functionStoppedRunningErr: (code: ErrCode) => string;
export declare const fixEventKeyMissingSteps: string[];
/**
 * An error that, when thrown, indicates internally that an outgoing operation
 * contains an error.
 *
 * We use this because serialized `data` sent back to Inngest may differ from
 * the error instance itself due to middleware.
 *
 * @internal
 */
export declare class OutgoingResultError extends Error {
    readonly result: Pick<OutgoingOp, "data" | "error">;
    constructor(result: Pick<OutgoingOp, "data" | "error">);
}
export {};
//# sourceMappingURL=errors.d.ts.map