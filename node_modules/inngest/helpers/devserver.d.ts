import { type FunctionConfig } from "../types";
/**
 * A simple type map that we can transparently use `fetch` later without having
 * to fall in to the self-referencing `const fetch: typeof fetch = ...` which
 * fails.
 */
type FetchT = typeof fetch;
/**
 * Attempts to contact the dev server, returning a boolean indicating whether or
 * not it was successful.
 *
 * @example devServerUrl(process.env[envKeys.DevServerUrl], "/your-path")
 */
export declare const devServerAvailable: (host: string | undefined, fetch: FetchT) => Promise<boolean>;
/**
 * devServerUrl returns a full URL for the given path name.
 *
 * Because Cloudflare/V8 platforms don't allow process.env, you are expected
 * to pass in the host from the dev server env key:
 *
 * @example devServerUrl(processEnv(envKeys.DevServerUrl), "/your-path")
 * @example devServerUrl("http://localhost:8288/", "/your-path")
 */
export declare const devServerUrl: (host?: string, pathname?: string) => URL;
export type InfoResponse = {
    version: string;
    startOpts: {
        sdkURLs: string[];
    };
    authed: boolean;
    workspaces: {
        prod: WorkspaceResponse;
        test: WorkspaceResponse;
    };
    functions: FunctionConfig[];
    handlers: SDKHandler[];
};
type WorkspaceResponse = {
    signingKey: string;
    eventKeys: Array<{
        name: string;
        key: string;
    }>;
};
type SDKHandler = {
    functionIDs: Array<string>;
    createdAt: string;
    updatedAt: string;
    errors: Array<string>;
    sdk: {
        url: string;
        language: string;
        version: string;
        framework?: string;
        app: string;
    };
};
export {};
//# sourceMappingURL=devserver.d.ts.map