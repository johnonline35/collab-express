import { type Jsonify } from "type-fest";
import { type ObjectPaths, type SendEventPayload } from "../helpers/types";
import { StepOpCode, type ClientOptions, type EventPayload, type HashedOp } from "../types";
import { type EventsFromOpts, type Inngest } from "./Inngest";
import { type ExecutionState } from "./InngestFunction";
export interface TickOp extends HashedOp {
    fn?: (...args: unknown[]) => unknown;
    fulfilled: boolean;
    resolve: (value: unknown | PromiseLike<unknown>) => void;
    reject: (reason?: unknown) => void;
}
/**
 * Create a new set of step function tools ready to be used in a step function.
 * This function should be run and a fresh set of tools provided every time a
 * function is run.
 *
 * An op stack (function state) is passed in as well as some mutable properties
 * that the tools can use to submit a new op.
 */
export declare const createStepTools: <TOpts extends ClientOptions, Events extends EventsFromOpts<TOpts>, TriggeringEvent extends keyof Events & string>(client: Inngest<TOpts>, state: ExecutionState) => {
    /**
     * Send one or many events to Inngest. Should always be used in place of
     * `inngest.send()` to ensure that the event send is successfully retried
     * and not sent multiple times due to memoisation.
     *
     * @example
     * ```ts
     * await step.sendEvent("app/user.created", { data: { id: 123 } });
     *
     * await step.sendEvent({ name: "app/user.created", data: { id: 123 } });
     *
     * await step.sendEvent([
     *   {
     *     name: "app/user.created",
     *     data: { id: 123 },
     *   },
     *   {
     *     name: "app/user.feed.created",
     *     data: { id: 123 },
     *   },
     * ]);
     * ```
     *
     * Returns a promise that will resolve once the event has been sent.
     */
    sendEvent: <Payload extends SendEventPayload<EventsFromOpts<TOpts>>>(payload: Payload) => Promise<void>;
    /**
     * Wait for a particular event to be received before continuing. When the
     * event is received, it will be returned.
     *
     * You can also provide options to control the particular event that is
     * received, for example to ensure that a user ID matches between two
     * events, or to only wait a maximum amount of time before giving up and
     * returning `null` instead of any event data.
     */
    waitForEvent: <IncomingEvent extends EventPayload | keyof Events>(event: IncomingEvent extends keyof Events ? IncomingEvent : IncomingEvent extends EventPayload ? IncomingEvent["name"] : never, opts: string | ((IncomingEvent extends keyof Events ? WaitForEventOpts<Events[TriggeringEvent], Events[IncomingEvent]> : IncomingEvent extends EventPayload ? WaitForEventOpts<Events[TriggeringEvent], IncomingEvent> : never) & {
        if?: undefined;
    }) | ((IncomingEvent extends keyof Events ? WaitForEventOpts<Events[TriggeringEvent], Events[IncomingEvent]> : IncomingEvent extends EventPayload ? WaitForEventOpts<Events[TriggeringEvent], IncomingEvent> : never) & {
        match?: undefined;
    })) => Promise<IncomingEvent extends keyof Events ? Events[IncomingEvent] | null : IncomingEvent | null>;
    /**
     * Use this tool to run business logic. Each call to `run` will be retried
     * individually, meaning you can compose complex workflows that safely
     * retry dependent asynchronous actions.
     *
     * The function you pass to `run` will be called only when this "step" is to
     * be executed and can be synchronous or asynchronous.
     *
     * In either case, the return value of the function will be the return value
     * of the `run` tool, meaning you can return and reason about return data
     * for next steps.
     */
    run: <T extends () => unknown>(name: string, fn: T) => Promise<Jsonify<T extends () => Promise<infer U> ? Awaited<U extends void ? null : U> : ReturnType<T> extends void ? null : ReturnType<T>>>;
    /**
     * Wait a specified amount of time before continuing.
     *
     * The time to wait can be specified using a `number` of milliseconds or an
     * `ms`-compatible time string like `"1 hour"`, `"30 mins"`, or `"2.5d"`.
     *
     * {@link https://npm.im/ms}
     *
     * To wait until a particular date, use `sleepUntil` instead.
     */
    sleep: (time: number | string) => Promise<void>;
    /**
     * Wait until a particular date before continuing by passing a `Date`.
     *
     * To wait for a particular amount of time from now, always use `sleep`
     * instead.
     */
    sleepUntil: (time: Date | string) => Promise<void>;
};
/**
 * A set of optional parameters given to a `waitForEvent` call to control how
 * the event is handled.
 */
interface WaitForEventOpts<TriggeringEvent extends EventPayload, IncomingEvent extends EventPayload> {
    /**
     * The step function will wait for the event for a maximum of this time, at
     * which point the event will be returned as `null` instead of any event data.
     *
     * The time to wait can be specified using a `number` of milliseconds, an
     * `ms`-compatible time string like `"1 hour"`, `"30 mins"`, or `"2.5d"`, or
     * a `Date` object.
     *
     * {@link https://npm.im/ms}
     */
    timeout: number | string | Date;
    /**
     * If provided, the step function will wait for the incoming event to match
     * particular criteria. If the event does not match, it will be ignored and
     * the step function will wait for another event.
     *
     * It must be a string of a dot-notation field name within both events to
     * compare, e.g. `"data.id"` or `"user.email"`.
     *
     * ```
     * // Wait for an event where the `user.email` field matches
     * match: "user.email"
     * ```
     *
     * All of these are helpers for the `if` option, which allows you to specify
     * a custom condition to check. This can be useful if you need to compare
     * multiple fields or use a more complex condition.
     *
     * See the Inngest expressions docs for more information.
     *
     * {@link https://www.inngest.com/docs/functions/expressions}
     */
    match?: ObjectPaths<TriggeringEvent> & ObjectPaths<IncomingEvent>;
    /**
     * If provided, the step function will wait for the incoming event to match
     * the given condition. If the event does not match, it will be ignored and
     * the step function will wait for another event.
     *
     * The condition is a string of Google's Common Expression Language. For most
     * simple cases, you might prefer to use `match` instead.
     *
     * See the Inngest expressions docs for more information.
     *
     * {@link https://www.inngest.com/docs/functions/expressions}
     */
    if?: string;
}
/**
 * An operation ready to hash to be used to memoise step function progress.
 *
 * @internal
 */
export type UnhashedOp = {
    name: string;
    op: StepOpCode;
    opts: Record<string, unknown> | null;
    parent: string | null;
    pos?: number;
};
/**
 * Exported for testing.
 */
export declare const _internals: {
    hashData: (op: UnhashedOp) => string;
};
export {};
//# sourceMappingURL=InngestStepTools.d.ts.map