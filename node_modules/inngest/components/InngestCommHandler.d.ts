import { ServerTiming } from "../helpers/ServerTiming";
import { type MaybePromise } from "../helpers/types";
import { type FunctionConfig, type LogLevel, type RegisterOptions, type RegisterRequest, type StepRunResponse } from "../types";
import { type Inngest } from "./Inngest";
import { type InngestFunction } from "./InngestFunction";
/**
 * A handler for serving Inngest functions. This type should be used
 * whenever a handler for a new framework is being added to enforce that the
 * registration process is always the same for the user.
 *
 * @example
 * ```
 * // my-custom-handler.ts
 * import { InngestCommHandler, ServeHandler } from "inngest";
 *
 * export const serve: ServeHandler = (nameOrInngest, fns, opts) => {
 *   const handler = new InngestCommHandler(
 *     "my-custom-handler",
 *     nameOrInngest,
 *     fns,
 *     opts,
 *     () => { ... },
 *     () => { ... }
 *   );
 *
 *   return handler.createHandler();
 * };
 * ```
 *
 * @public
 */
export type ServeHandler = (
/**
 * The name of this app, used to scope and group Inngest functions, or
 * the `Inngest` instance used to declare all functions.
 */
client: Inngest<any>, 
/**
 * An array of the functions to serve and register with Inngest.
 */
functions: InngestFunction<any, any, any, any>[], 
/**
 * A set of options to further configure the registration of Inngest
 * functions.
 */
opts?: RegisterOptions
/**
 * This `any` return is appropriate.
 *
 * While we can infer the signature of the returned value, we cannot guarantee
 * that we have used the same types as the framework we are integrating with,
 * which sometimes can cause frustrating collisions for a user that result in
 * `as unknown as X` casts.
 *
 * Instead, we will use `any` here and have the user be able to place it
 * anywhere they need.
 */
) => any;
/**
 * `InngestCommHandler` is a class for handling incoming requests from Inngest (or
 * Inngest's tooling such as the dev server or CLI) and taking appropriate
 * action for any served functions.
 *
 * All handlers (Next.js, RedwoodJS, Remix, Deno Fresh, etc) are created using
 * this class; the exposed `serve` function will - most commonly - create an
 * instance of `InngestCommHandler` and then return `instance.createHandler()`.
 *
 * Two critical parameters required are the `handler` and the `transformRes`
 * function. See individual parameter details for more information, or see the
 * source code for an existing handler, e.g.
 * {@link https://github.com/inngest/inngest-js/blob/main/src/next.ts}
 *
 * @example
 * ```
 * // my-custom-handler.ts
 * import { InngestCommHandler, ServeHandler } from "inngest";
 *
 * export const serve: ServeHandler = (nameOrInngest, fns, opts) => {
 *   const handler = new InngestCommHandler(
 *     "my-custom-handler",
 *     nameOrInngest,
 *     fns,
 *     opts,
 *     () => { ... },
 *     () => { ... }
 *   );
 *
 *   return handler.createHandler();
 * };
 * ```
 *
 * @public
 */
export declare class InngestCommHandler<H extends Handler, TResTransform extends (res: ActionResponse<string>, ...args: Parameters<H>) => any, TStreamTransform extends (res: ActionResponse<ReadableStream>, ...args: Parameters<H>) => any> {
    /**
     * The name of this serve handler, e.g. `"My App"`. It's recommended that this
     * value represents the overarching app/service that this set of functions is
     * being served from.
     */
    readonly name: string;
    /**
     * The handler specified during instantiation of the class.
     */
    readonly handler: H;
    /**
     * The response transformer specified during instantiation of the class.
     */
    readonly transformRes: TResTransform;
    readonly streamTransformRes: TStreamTransform | undefined;
    /**
     * The URL of the Inngest function registration endpoint.
     */
    private readonly inngestRegisterUrl;
    /**
     * The name of the framework this handler is designed for. Should be
     * lowercase, alphanumeric characters inclusive of `-` and `/`. This should
     * never be defined by the user; a {@link ServeHandler} should abstract this.
     */
    protected readonly frameworkName: string;
    /**
     * The signing key used to validate requests from Inngest. This is
     * intentionally mutatble so that we can pick up the signing key from the
     * environment during execution if needed.
     */
    protected signingKey: string | undefined;
    /**
     * A property that can be set to indicate whether or not we believe we are in
     * production mode.
     *
     * Should be set every time a request is received.
     */
    protected _isProd: boolean;
    /**
     * Whether we should attempt to use the dev server.
     *
     * Should be set every time a request is received.
     */
    protected _skipDevServer: boolean;
    /**
     * The localized `fetch` implementation used by this handler.
     */
    private readonly fetch;
    /**
     * Whether we should show the SDK Landing Page.
     *
     * This purposefully does not take in to account any environment variables, as
     * accessing them safely is platform-specific.
     */
    protected readonly showLandingPage: boolean | undefined;
    /**
     * The host used to access the Inngest serve endpoint, e.g.:
     *
     *     "https://myapp.com"
     *
     * By default, the library will try to infer this using request details such
     * as the "Host" header and request path, but sometimes this isn't possible
     * (e.g. when running in a more controlled environments such as AWS Lambda or
     * when dealing with proxies/rediects).
     *
     * Provide the custom hostname here to ensure that the path is reported
     * correctly when registering functions with Inngest.
     *
     * To also provide a custom path, use `servePath`.
     */
    protected readonly serveHost: string | undefined;
    /**
     * The path to the Inngest serve endpoint. e.g.:
     *
     *     "/some/long/path/to/inngest/endpoint"
     *
     * By default, the library will try to infer this using request details such
     * as the "Host" header and request path, but sometimes this isn't possible
     * (e.g. when running in a more controlled environments such as AWS Lambda or
     * when dealing with proxies/rediects).
     *
     * Provide the custom path (excluding the hostname) here to ensure that the
     * path is reported correctly when registering functions with Inngest.
     *
     * To also provide a custom hostname, use `serveHost`.
     */
    protected readonly servePath: string | undefined;
    /**
     * The minimum level to log from the Inngest serve handler.
     */
    protected readonly logLevel: LogLevel;
    protected readonly streaming: RegisterOptions["streaming"];
    /**
     * A private collection of just Inngest functions, as they have been passed
     * when instantiating the class.
     */
    private readonly rawFns;
    private readonly client;
    /**
     * A private collection of functions that are being served. This map is used
     * to find and register functions when interacting with Inngest Cloud.
     */
    private readonly fns;
    private allowExpiredSignatures;
    constructor(
    /**
     * The name of the framework this handler is designed for. Should be
     * lowercase, alphanumeric characters inclusive of `-` and `/`.
     *
     * This should never be defined by the user; a {@link ServeHandler} should
     * abstract this.
     */
    frameworkName: string, 
    /**
     * The name of this serve handler, e.g. `"My App"`. It's recommended that this
     * value represents the overarching app/service that this set of functions is
     * being served from.
     *
     * This can also be an `Inngest` client, in which case the name given when
     * instantiating the client is used. This is useful if you're sending and
     * receiving events from the same service, as you can reuse a single
     * definition of Inngest.
     */
    client: Inngest<any>, 
    /**
     * An array of the functions to serve and register with Inngest.
     */
    functions: InngestFunction<any, any, any, any>[], { inngestRegisterUrl, fetch, landingPage, logLevel, signingKey, serveHost, servePath, streaming, name, }: RegisterOptions | undefined, 
    /**
     * The `handler` is the function your framework requires to handle a
     * request. For example, this is most commonly a function that is given a
     * `Request` and must return a `Response`.
     *
     * The handler must map out any incoming parameters, then return a
     * strictly-typed object to assess what kind of request is being made,
     * collecting any relevant data as we go.
     *
     * @example
     * ```
     * return {
     *   register: () => { ... },
     *   run: () => { ... },
     *   view: () => { ... }
     * };
     * ```
     *
     * Every key must be specified and must be a function that either returns
     * a strictly-typed payload or `undefined` if the request is not for that
     * purpose.
     *
     * This gives handlers freedom to choose how their platform of choice will
     * trigger differing actions, whilst also ensuring all required information
     * is given for each request type.
     *
     * See any existing handler for a full example.
     *
     * This should never be defined by the user; a {@link ServeHandler} should
     * abstract this.
     */
    handler: H, 
    /**
     * The `transformRes` function receives the output of the Inngest SDK and
     * can decide how to package up that information to appropriately return the
     * information to Inngest.
     *
     * Mostly, this is taking the given parameters and returning a new
     * `Response`.
     *
     * The function is passed an {@link ActionResponse} (an object containing a
     * `status` code, a `headers` object, and a stringified `body`), as well as
     * every parameter passed to the given `handler` function. This ensures you
     * can appropriately handle the response, including use of any required
     * parameters such as `res` in Express-/Connect-like frameworks.
     *
     * This should never be defined by the user; a {@link ServeHandler} should
     * abstract this.
     */
    transformRes: TResTransform, 
    /**
     * The `streamTransformRes` function, if defined, declares that this handler
     * supports streaming responses back to Inngest. This is useful for
     * functions that are expected to take a long time, as edge streaming can
     * often circumvent restrictive request timeouts and other limitations.
     *
     * If your handler does not support streaming, do not define this function.
     *
     * It receives the output of the Inngest SDK and can decide how to package
     * up that information to appropriately return the information in a stream
     * to Inngest.
     *
     * Mostly, this is taking the given parameters and returning a new
     * `Response`.
     *
     * The function is passed an {@link ActionResponse} (an object containing a
     * `status` code, a `headers` object, and `body`, a `ReadableStream`), as
     * well as every parameter passed to the given `handler` function. This
     * ensures you can appropriately handle the response, including use of any
     * required parameters such as `res` in Express-/Connect-like frameworks.
     *
     * This should never be defined by the user; a {@link ServeHandler} should
     * abstract this.
     */
    streamTransformRes?: TStreamTransform);
    private get hashedSigningKey();
    /**
     * `createHandler` should be used to return a type-equivalent version of the
     * `handler` specified during instantiation.
     *
     * @example
     * ```
     * // my-custom-handler.ts
     * import { InngestCommHandler, ServeHandler } from "inngest";
     *
     * export const serve: ServeHandler = (nameOrInngest, fns, opts) => {
     *   const handler = new InngestCommHandler(
     *     "my-custom-handler",
     *     nameOrInngest,
     *     fns,
     *     opts,
     *     () => { ... },
     *     () => { ... }
     *   );
     *
     *   return handler.createHandler();
     * };
     * ```
     */
    createHandler(): (...args: Parameters<H>) => Promise<Awaited<ReturnType<TResTransform>>>;
    /**
     * Given a set of functions to check if an action is available from the
     * instance's handler, enact any action that is found.
     *
     * This method can fetch varying payloads of data, but ultimately is the place
     * where _decisions_ are made regarding functionality.
     *
     * For example, if we find that we should be viewing the UI, this function
     * will decide whether the UI should be visible based on the payload it has
     * found (e.g. env vars, options, etc).
     */
    private handleAction;
    protected runStep(functionId: string, stepId: string | null, data: unknown, timer: ServerTiming): Promise<StepRunResponse>;
    protected configs(url: URL): FunctionConfig[];
    /**
     * Return an Inngest serve endpoint URL given a potential `path` and `host`.
     *
     * Will automatically use the `serveHost` and `servePath` if they have been
     * set when registering.
     */
    protected reqUrl(url: URL): URL;
    protected registerBody(url: URL): RegisterRequest;
    protected register(url: URL, devServerHost: string | undefined, deployId: string | undefined | null, getHeaders: () => Record<string, string>): Promise<{
        status: number;
        message: string;
    }>;
    private get isProd();
    private upsertSigningKeyFromEnv;
    protected shouldShowLandingPage(strEnvVar: string | undefined): boolean;
    protected validateSignature(sig: string | undefined, body: Record<string, unknown>): void;
    protected signResponse(): string;
    /**
     * Log to stdout/stderr if the log level is set to include the given level.
     * The default log level is `"info"`.
     *
     * This is an abstraction over `console.log` and will try to use the correct
     * method for the given log level.  For example, `log("error", "foo")` will
     * call `console.error("foo")`.
     */
    protected log(level: LogLevel, ...args: unknown[]): void;
}
/**
 * The broad definition of a handler passed when instantiating an
 * {@link InngestCommHandler} instance.
 */
type Handler = (...args: any[]) => {
    env?: Record<string, unknown>;
    isProduction?: boolean;
    url: URL;
} & {
    [K in Extract<HandlerAction, {
        action: "run" | "register" | "view";
    }>["action"]]: () => MaybePromise<Omit<Extract<HandlerAction, {
        action: K;
    }>, "action"> | undefined>;
};
/**
 * The response from the Inngest SDK before it is transformed in to a
 * framework-compatible response by an {@link InngestCommHandler} instance.
 */
export interface ActionResponse<TBody extends string | ReadableStream = string> {
    /**
     * The HTTP status code to return.
     */
    status: number;
    /**
     * The headers to return in the response.
     */
    headers: Record<string, string>;
    /**
     * A stringified body to return.
     */
    body: TBody;
}
/**
 * A set of actions the SDK is aware of, including any payloads they require
 * when requesting them.
 */
type HandlerAction = {
    action: "error";
    data: Record<string, string>;
} | {
    action: "view";
    isIntrospection: boolean;
} | {
    action: "register";
    deployId?: null | string;
} | {
    action: "run";
    fnId: string;
    stepId: string | null;
    data: Record<string, unknown>;
    signature: string | undefined;
} | {
    action: "bad-method";
};
export {};
//# sourceMappingURL=InngestCommHandler.d.ts.map