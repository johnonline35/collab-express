import { type Simplify } from "type-fest";
import { type Await, type MaybePromise, type ObjectAssign, type PartialK } from "../helpers/types";
import { type BaseContext, type ClientOptions, type EventPayload, type IncomingOp, type MiddlewareStack, type OutgoingOp } from "../types";
import { type Inngest } from "./Inngest";
import { type InngestFunction } from "./InngestFunction";
/**
 * A middleware that can be registered with Inngest to hook into various
 * lifecycles of the SDK and affect input and output of Inngest functionality.
 *
 * TODO Add docs and shortlink.
 *
 * See {@link https://innge.st/middleware}
 *
 * @example
 *
 * ```ts
 * export const inngest = new Inngest({
 *   middleware: [
 *     new InngestMiddleware({
 *       name: "My Middleware",
 *       register: () => {
 *         // ...
 *       }
 *     })
 *   ]
 * });
 * ```
 *
 * @public
 */
export declare class InngestMiddleware<TOpts extends MiddlewareOptions> {
    /**
     * The name of this middleware. Used primarily for debugging and logging
     * purposes.
     */
    readonly name: TOpts["name"];
    /**
     * This function is used to initialize your middleware and register any hooks
     * you want to use. It will be called once when the SDK is initialized, and
     * should be used to store any state you want to use in other parts of your
     * middleware.
     *
     * It can be synchronous or asynchronous, in which case the client will wait
     * for it to resolve before continuing to initialize the next middleware.
     *
     * Multiple clients could be used in the same application with differing
     * middleware, so do not store state in global variables or assume that your
     * middleware will only be used once.
     *
     * Must return an object detailing the hooks you want to register.
     */
    readonly init: TOpts["init"];
    constructor({ name, init }: TOpts);
}
type FnsWithSameInputAsOutput<TRecord extends Record<string, (arg: any) => any>> = {
    [K in keyof TRecord as Await<TRecord[K]> extends Parameters<TRecord[K]>[0] ? K : Await<TRecord[K]> extends void | undefined ? Parameters<TRecord[K]>[0] extends void | undefined ? K : never : never]: TRecord[K];
};
type PromisifiedFunctionRecord<TRecord extends Record<string, (arg: any) => any>> = Pick<Partial<{
    [K in keyof TRecord]: (...args: Parameters<TRecord[K]>) => Promise<Await<TRecord[K]>>;
}>, keyof FnsWithSameInputAsOutput<TRecord>> & Omit<Partial<{
    [K in keyof TRecord]: (...args: Parameters<TRecord[K]>) => Promise<Parameters<TRecord[K]>[0]>;
}>, keyof FnsWithSameInputAsOutput<TRecord>>;
export type RunHookStack = PromisifiedFunctionRecord<Await<MiddlewareRegisterReturn["onFunctionRun"]>>;
/**
 * Given some middleware and an entrypoint, runs the initializer for the given
 * `key` and returns functions that will pass arguments through a stack of each
 * given hook in a middleware's lifecycle.
 *
 * Lets the middleware initialize before starting.
 */
export declare const getHookStack: <TMiddleware extends Record<string, (arg: any) => any>, TKey extends keyof TMiddleware, TResult extends Await<TMiddleware[TKey]>, TRet extends PromisifiedFunctionRecord<TResult> = PromisifiedFunctionRecord<TResult>>(middleware: Promise<TMiddleware[]>, key: TKey, arg: Parameters<TMiddleware[TKey]>[0], transforms: PartialK<{ [K in keyof TResult]-?: (prev: Parameters<TResult[K]>[0], output: Await<TResult[K]>) => Parameters<TResult[K]>[0]; }, keyof { [K_1 in keyof TResult as Await<TResult[K_1]> extends Parameters<TResult[K_1]>[0] ? K_1 : Await<TResult[K_1]> extends void | undefined ? Parameters<TResult[K_1]>[0] extends void | undefined ? K_1 : never : never]: void; }>) => Promise<TRet>;
/**
 * Options passed to new {@link InngestMiddleware} instance.
 *
 * @public
 */
export interface MiddlewareOptions {
    /**
     * The name of this middleware. Used primarily for debugging and logging
     * purposes.
     */
    name: string;
    /**
     * This function is used to initialize your middleware and register any hooks
     * you want to use. It will be called once when the SDK is initialized, and
     * should be used to store any state you want to use in other parts of your
     * middleware.
     *
     * It can be synchronous or asynchronous, in which case the client will wait
     * for it to resolve before continuing to initialize the next middleware.
     *
     * Multiple clients could be used in the same application with differing
     * middleware, so do not store state in global variables or assume that your
     * middleware will only be used once.
     *
     * Must return an object detailing the hooks you want to register.
     */
    init: MiddlewareRegisterFn;
}
/**
 * @public
 */
export type MiddlewareRegisterReturn = {
    /**
     * This hook is called for every function execution and allows you to hook
     * into various stages of a run's lifecycle. Use this to store any state you
     * want to use for the entirety of a particular run.
     *
     * It can be synchronous or asynchronous, in which case the client will wait
     * for it to resolve before continuing to initialize the next middleware.
     *
     * Must return an object detailing the hooks you want to register.
     */
    onFunctionRun?: (ctx: InitialRunInfo) => MaybePromise<{
        /**
         * The `input` hook is called once the input for the function has been
         * properly set up. This is where you can modify the input before the
         * function starts to memoize or execute by returning an object containing
         * changes to the context.
         *
         * For example, to add `foo` to the context, you'd return
         * `{ ctx: { foo: "bar" } }`.
         *
         * @param ctx - The context for the incoming request.
         * @param steps - The step data in state. Does not include internal IDs.
         */
        transformInput?: MiddlewareRunInput;
        /**
         * The `beforeMemoization` hook is called before the function starts to
         * memoize.
         */
        beforeMemoization?: BlankHook;
        /**
         * The `afterMemoization` hook is called after the function has finished
         * memoizing.
         */
        afterMemoization?: BlankHook;
        /**
         * The `beforeExecution` hook is called before the function starts to
         * execute. Execution here means that new code is being seen/run for the
         * first time.
         */
        beforeExecution?: BlankHook;
        /**
         * The `afterExecution` hook is called after the function has finished
         * executing.
         */
        afterExecution?: BlankHook;
        /**
         * The `output` hook is called after the function has finished executing
         * and before the response is sent back to Inngest. This is where you
         * can modify the output before it's sent back to Inngest by returning
         * an object containing changes.
         *
         * @param err - The raw error that was thrown by the function, if any, so
         * that you can capture exact error messages and stack traces.
         *
         * @param data - The prepared-but-unserialized data that was returned by
         * the function, if any, so that you can modify the output.
         */
        transformOutput?: MiddlewareRunOutput;
        /**
         * The `beforeResponse` hook is called after the output has been set and
         * before the response is sent back to Inngest. This is where you can
         * perform any final actions before the response is sent back to Inngest.
         */
        beforeResponse?: BlankHook;
    }>;
    /**
     * The `sendEvent` hook is called every time an event is sent to Inngest.
     */
    onSendEvent?: () => MaybePromise<{
        /**
         * The `input` hook is called before the event is sent to Inngest. This
         * is where you can modify the event before it's sent to Inngest by
         * returning an object containing changes.
         */
        transformInput?: MiddlewareSendEventInput;
        /**
         * The `output` hook is called after the event has been sent to Inngest.
         * This is where you can perform any final actions after the event has
         * been sent to Inngest and can modify the output the SDK sees.
         *
         * TODO This needs to be a result object that we spread into, not just some
         * unknown value.
         */
        transformOutput?: MiddlewareSendEventOutput;
    }>;
};
/**
 * @public
 */
export type MiddlewareRegisterFn = (ctx: {
    /**
     * The client this middleware is being registered on.
     *
     * TODO This should not use `any`, but the generic type expected.
     */
    client: Inngest<any>;
    /**
     * If defined, this middleware has been applied directly to an Inngest
     * function rather than on the client.
     *
     * TODO This should not use `any`, but the generic type expected.
     */
    fn?: InngestFunction<any, any, any, any>;
}) => MaybePromise<MiddlewareRegisterReturn>;
/**
 * A blank, no-op hook that passes nothing and expects nothing in return.
 *
 * @internal
 */
type BlankHook = () => MaybePromise<void>;
/**
 * Arguments sent to some `run` lifecycle hooks of a middleware.
 *
 * @internal
 */
type MiddlewareRunArgs = Readonly<{
    /**
     * The context object that will be passed to the function. This contains
     * event data, some contextual data such as the run's ID, and step tooling.
     */
    ctx: Record<string, unknown> & Readonly<BaseContext<ClientOptions, string, Record<string, (...args: unknown[]) => unknown>>>;
    /**
     * The step data that will be passed to the function.
     */
    steps: Readonly<Omit<IncomingOp, "id">>[];
    /**
     * The function that is being executed.
     *
     * TODO This should not use `any`, but the generic type expected.
     */
    fn: InngestFunction<any, any, any, any>;
}>;
/**
 * The specific arguments sent to the `run` hook when an execution has begun.
 * Differs from {@link MiddlewareRunArgs} in that we don't have a complete
 * context yet.
 *
 * @internal
 */
type InitialRunInfo = Readonly<Simplify<Omit<MiddlewareRunArgs, "ctx"> & {
    /**
     * A partial context object that will be passed to the function. Does not
     * necessarily contain all the data that will be passed to the function.
     */
    ctx: Pick<MiddlewareRunArgs["ctx"], "event" | "runId">;
}>>;
/**
 * The shape of an `input` hook within a `run`, optionally returning change to
 * the context or steps.
 *
 * @internal
 */
type MiddlewareRunInput = (ctx: MiddlewareRunArgs) => MaybePromise<{
    ctx?: Record<string, unknown>;
    steps?: Pick<IncomingOp, "data">[];
} | void>;
/**
 * Arguments sent to some `sendEvent` lifecycle hooks of a middleware.
 *
 * @internal
 */
type MiddlewareSendEventArgs = Readonly<{
    payloads: ReadonlyArray<EventPayload>;
}>;
/**
 * The shape of an `input` hook within a `sendEvent`, optionally returning
 * change to the payloads.
 *
 * @internal
 */
type MiddlewareSendEventInput = (ctx: MiddlewareSendEventArgs) => MaybePromise<{
    payloads?: EventPayload[];
} | void>;
/**
 * The shape of an `output` hook within a `sendEvent`, optionally returning a
 * change to the result value.
 */
type MiddlewareSendEventOutput = (ctx: MiddlewareSendEventArgs) => MaybePromise<void>;
/**
 * @internal
 */
type MiddlewareRunOutput = (ctx: {
    result: Readonly<Pick<OutgoingOp, "error" | "data">>;
    step?: Readonly<Omit<OutgoingOp, "id">>;
}) => {
    result?: Partial<Pick<OutgoingOp, "data">>;
} | void;
/**
 * @internal
 */
type GetMiddlewareRunInputMutation<TMiddleware extends InngestMiddleware<MiddlewareOptions>> = TMiddleware extends InngestMiddleware<infer TOpts> ? TOpts["init"] extends MiddlewareRegisterFn ? Await<Await<Await<TOpts["init"]>["onFunctionRun"]>["transformInput"]> extends {
    ctx: infer TCtx;
} ? {
    [K in keyof TCtx]: TCtx[K];
} : {} : {} : {};
/**
 * @internal
 */
export type MiddlewareStackRunInputMutation<TContext, TMiddleware extends MiddlewareStack> = ObjectAssign<{
    [K in keyof TMiddleware]: GetMiddlewareRunInputMutation<TMiddleware[K]>;
}, TContext>;
export {};
//# sourceMappingURL=InngestMiddleware.d.ts.map