import { type ClientOptions, type EventNameFromTrigger, type FunctionOptions, type FunctionTrigger, type Handler } from "../types";
import { type EventsFromOpts, type Inngest } from "./Inngest";
import { type TickOp } from "./InngestStepTools";
/**
 * A stateless Inngest function, wrapping up function configuration and any
 * in-memory steps to run when triggered.
 *
 * This function can be "registered" to create a handler that Inngest can
 * trigger remotely.
 *
 * @public
 */
export declare class InngestFunction<TOpts extends ClientOptions = ClientOptions, Events extends EventsFromOpts<TOpts> = EventsFromOpts<TOpts>, Trigger extends FunctionTrigger<keyof Events & string> = FunctionTrigger<keyof Events & string>, Opts extends FunctionOptions<Events, EventNameFromTrigger<Events, Trigger>> = FunctionOptions<Events, EventNameFromTrigger<Events, Trigger>>> {
    #private;
    static stepId: string;
    static failureSuffix: string;
    readonly opts: Opts;
    readonly trigger: Trigger;
    private readonly middleware;
    /**
     * A stateless Inngest function, wrapping up function configuration and any
     * in-memory steps to run when triggered.
     *
     * This function can be "registered" to create a handler that Inngest can
     * trigger remotely.
     */
    constructor(client: Inngest<TOpts>, 
    /**
     * Options
     */
    opts: Opts, trigger: Trigger, fn: Handler<TOpts, Events, keyof Events & string>);
    /**
     * The generated or given ID for this function.
     */
    id(prefix?: string): string;
    /**
     * The name of this function as it will appear in the Inngest Cloud UI.
     */
    get name(): string;
    /**
     * Retrieve the Inngest config for this function.
     */
    private getConfig;
    /**
     * Run this function, optionally providing an op stack to pass as state.
     *
     * It is a `private` method to prevent users from being exposed to it
     * directly, but ensuring it is available to the generated handler.
     *
     * For a single-step function that doesn't use any step tooling, this will
     * await the result of the function given to this instance of
     * `InngestFunction` and return the data and a boolean indicating that the
     * function is complete and should not be called again.
     *
     * For a multi-step function, also try to await the result of the function
     * given to this instance of `InngestFunction`, though will check whether an
     * op has been submitted for use (or a Promise is pending, such as a step
     * running) after the function has completed.
     */
    private runFn;
}
export interface ExecutionState {
    /**
     * The tree of all found ops in the entire invocation.
     */
    allFoundOps: Record<string, TickOp>;
    /**
     * All synchronous operations found in this particular tick. The array is
     * reset every tick.
     */
    tickOps: Record<string, TickOp>;
    /**
     * A hash of operations found within this tick, with keys being the hashed
     * ops themselves (without a position) and the values being the number of
     * times that op has been found.
     *
     * This is used to provide some mutation resilience to the op stack,
     * allowing us to survive same-tick mutations of code by ensuring per-tick
     * hashes are based on uniqueness rather than order.
     */
    tickOpHashes: Record<string, number>;
    /**
     * Tracks the current operation being processed. This can be used to
     * understand the contextual parent of any recorded operations.
     */
    currentOp: TickOp | undefined;
    /**
     * If we've found a user function to run, we'll store it here so a component
     * higher up can invoke and await it.
     */
    userFnToRun?: (...args: unknown[]) => unknown;
    /**
     * A boolean to represent whether the user's function is using any step
     * tools.
     *
     * If the function survives an entire tick of the event loop and hasn't
     * touched any tools, we assume that it is a single-step async function and
     * should be awaited as usual.
     */
    hasUsedTools: boolean;
    /**
     * A function that should be used to reset the state of the tools after a
     * tick has completed.
     */
    reset: () => void;
    /**
     * If `true`, any use of step tools will, by default, throw an error. We do
     * this when we detect that a function may be mixing step and non-step code.
     *
     * Created step tooling can decide how to manually handle this on a
     * case-by-case basis.
     *
     * In the future, we can provide a way for a user to override this if they
     * wish to and understand the danger of side-effects.
     *
     * Defaults to `false`.
     */
    nonStepFnDetected: boolean;
    /**
     * When true, we are currently executing a user's code for a single step
     * within a step function.
     */
    executingStep: boolean;
}
export declare const createExecutionState: () => ExecutionState;
//# sourceMappingURL=InngestFunction.d.ts.map