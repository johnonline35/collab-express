"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports._internals = exports.createStepTools = void 0;
const canonicalize_1 = __importDefault(require("canonicalize"));
const hash_js_1 = require("hash.js");
const errors_1 = require("../helpers/errors");
const strings_1 = require("../helpers/strings");
const types_1 = require("../types");
const NonRetriableError_1 = require("./NonRetriableError");
/**
 * Create a new set of step function tools ready to be used in a step function.
 * This function should be run and a fresh set of tools provided every time a
 * function is run.
 *
 * An op stack (function state) is passed in as well as some mutable properties
 * that the tools can use to submit a new op.
 */
const createStepTools = (client, state) => {
    // Start referencing everything
    state.tickOps = state.allFoundOps;
    /**
     * Create a unique hash of an operation using only a subset of the operation's
     * properties; will never use `data` and will guarantee the order of the object
     * so we don't rely on individual tools for that.
     */
    const hashOp = (
    /**
     * The op to generate a hash from. We only use a subset of the op's properties
     * when creating the hash.
     */
    op) => {
        var _a, _b, _c, _d;
        const obj = {
            parent: (_b = (_a = state.currentOp) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : null,
            op: op.op,
            name: op.name,
            opts: (_c = op.opts) !== null && _c !== void 0 ? _c : null,
        };
        const collisionHash = exports._internals.hashData(obj);
        const pos = (state.tickOpHashes[collisionHash] =
            ((_d = state.tickOpHashes[collisionHash]) !== null && _d !== void 0 ? _d : -1) + 1);
        return Object.assign(Object.assign({}, op), { id: exports._internals.hashData(Object.assign({ pos }, obj)) });
    };
    /**
     * A local helper used to create tools that can be used to submit an op.
     *
     * When using this function, a generic type should be provided which is the
     * function signature exposed to the user.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const createTool = (
    /**
     * A function that returns an ID for this op. This is used to ensure that
     * the op stack is correctly filled, submitted, and retrieved with the same
     * ID.
     *
     * It is passed the arguments passed by the user.
     *
     * Most simple tools will likely only need to define this.
     */
    matchOp, opts) => {
        return ((...args) => {
            if (state.nonStepFnDetected) {
                if ((opts === null || opts === void 0 ? void 0 : opts.nonStepExecuteInline) && opts.fn) {
                    return Promise.resolve(opts.fn(...args));
                }
                throw new NonRetriableError_1.NonRetriableError((0, errors_1.functionStoppedRunningErr)(errors_1.ErrCode.STEP_USED_AFTER_ASYNC));
            }
            if (state.executingStep) {
                throw new NonRetriableError_1.NonRetriableError((0, errors_1.prettyError)({
                    whatHappened: "Your function was stopped from running",
                    why: "We detected that you have nested `step.*` tooling.",
                    consequences: "Nesting `step.*` tooling is not supported.",
                    stack: true,
                    toFixNow: "Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.",
                    otherwise: "For more information on step functions with Inngest, see https://www.inngest.com/docs/functions/multi-step",
                    code: errors_1.ErrCode.NESTING_STEPS,
                }));
            }
            state.hasUsedTools = true;
            const opId = hashOp(matchOp(...args));
            return new Promise((resolve, reject) => {
                state.tickOps[opId.id] = Object.assign(Object.assign(Object.assign({}, opId), ((opts === null || opts === void 0 ? void 0 : opts.fn) ? { fn: () => { var _a; return (_a = opts.fn) === null || _a === void 0 ? void 0 : _a.call(opts, ...args); } } : {})), { resolve,
                    reject, fulfilled: false });
            });
        });
    };
    /**
     * Define the set of tools the user has access to for their step functions.
     *
     * Each key is the function name and is expected to run `createTool` and pass
     * a generic type for that function as it will appear in the user's code.
     */
    const tools = {
        /**
         * Send one or many events to Inngest. Should always be used in place of
         * `inngest.send()` to ensure that the event send is successfully retried
         * and not sent multiple times due to memoisation.
         *
         * @example
         * ```ts
         * await step.sendEvent("app/user.created", { data: { id: 123 } });
         *
         * await step.sendEvent({ name: "app/user.created", data: { id: 123 } });
         *
         * await step.sendEvent([
         *   {
         *     name: "app/user.created",
         *     data: { id: 123 },
         *   },
         *   {
         *     name: "app/user.feed.created",
         *     data: { id: 123 },
         *   },
         * ]);
         * ```
         *
         * Returns a promise that will resolve once the event has been sent.
         */
        sendEvent: createTool(() => {
            return {
                op: types_1.StepOpCode.StepPlanned,
                name: "sendEvent",
            };
        }, {
            nonStepExecuteInline: true,
            fn: (payload) => {
                return client.send(payload);
            },
        }),
        /**
         * Wait for a particular event to be received before continuing. When the
         * event is received, it will be returned.
         *
         * You can also provide options to control the particular event that is
         * received, for example to ensure that a user ID matches between two
         * events, or to only wait a maximum amount of time before giving up and
         * returning `null` instead of any event data.
         */
        waitForEvent: createTool((
        /**
         * The event name to wait for.
         */
        event, 
        /**
         * Options to control the event we're waiting for.
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        opts) => {
            const matchOpts = {
                timeout: (0, strings_1.timeStr)(typeof opts === "string" ? opts : opts.timeout),
            };
            if (typeof opts !== "string") {
                if (opts === null || opts === void 0 ? void 0 : opts.match) {
                    matchOpts.if = `event.${opts.match} == async.${opts.match}`;
                }
                else if (opts === null || opts === void 0 ? void 0 : opts.if) {
                    matchOpts.if = opts.if;
                }
            }
            return {
                op: types_1.StepOpCode.WaitForEvent,
                name: event,
                opts: matchOpts,
            };
        }),
        /**
         * Use this tool to run business logic. Each call to `run` will be retried
         * individually, meaning you can compose complex workflows that safely
         * retry dependent asynchronous actions.
         *
         * The function you pass to `run` will be called only when this "step" is to
         * be executed and can be synchronous or asynchronous.
         *
         * In either case, the return value of the function will be the return value
         * of the `run` tool, meaning you can return and reason about return data
         * for next steps.
         */
        run: createTool((name) => {
            return {
                op: types_1.StepOpCode.StepPlanned,
                name,
            };
        }, { fn: (_, fn) => fn() }),
        /**
         * Wait a specified amount of time before continuing.
         *
         * The time to wait can be specified using a `number` of milliseconds or an
         * `ms`-compatible time string like `"1 hour"`, `"30 mins"`, or `"2.5d"`.
         *
         * {@link https://npm.im/ms}
         *
         * To wait until a particular date, use `sleepUntil` instead.
         */
        sleep: createTool((time) => {
            /**
             * The presence of this operation in the returned stack indicates that the
             * sleep is over and we should continue execution.
             */
            return {
                op: types_1.StepOpCode.Sleep,
                name: (0, strings_1.timeStr)(time),
            };
        }),
        /**
         * Wait until a particular date before continuing by passing a `Date`.
         *
         * To wait for a particular amount of time from now, always use `sleep`
         * instead.
         */
        sleepUntil: createTool((time) => {
            const date = typeof time === "string" ? new Date(time) : time;
            /**
             * The presence of this operation in the returned stack indicates that the
             * sleep is over and we should continue execution.
             */
            try {
                return {
                    op: types_1.StepOpCode.Sleep,
                    name: date.toISOString(),
                };
            }
            catch (err) {
                /**
                 * If we're here, it's because the date is invalid. We'll throw a custom
                 * error here to standardise this response.
                 */
                // TODO PrettyError
                console.warn("Invalid date or date string passed to sleepUntil;", err);
                // TODO PrettyError
                throw new Error(`Invalid date or date string passed to sleepUntil: ${time.toString()}`);
            }
        }),
    };
    return tools;
};
exports.createStepTools = createStepTools;
const hashData = (op) => {
    return (0, hash_js_1.sha1)().update((0, canonicalize_1.default)(op)).digest("hex");
};
/**
 * Exported for testing.
 */
exports._internals = { hashData };
//# sourceMappingURL=InngestStepTools.js.map