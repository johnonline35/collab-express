import { type SendEventPayload } from "../helpers/types";
import { type Logger } from "../middleware/logger";
import { type ClientOptions, type EventNameFromTrigger, type EventPayload, type FailureEventArgs, type FunctionOptions, type FunctionTrigger, type Handler, type MiddlewareStack, type ShimmedFns, type TriggerOptions } from "../types";
import { type EventSchemas } from "./EventSchemas";
import { InngestFunction } from "./InngestFunction";
import { InngestMiddleware, type MiddlewareStackRunInputMutation } from "./InngestMiddleware";
/**
 * Given a set of client options for Inngest, return the event types that can
 * be sent or received.
 *
 * @public
 */
export type EventsFromOpts<TOpts extends ClientOptions> = TOpts["schemas"] extends EventSchemas<infer U> ? U : Record<string, EventPayload>;
/**
 * A client used to interact with the Inngest API by sending or reacting to
 * events.
 *
 * To provide event typing, see {@link EventSchemas}.
 *
 * ```ts
 * const inngest = new Inngest({ name: "My App" });
 *
 * // or to provide event typing too
 * const inngest = new Inngest({
 *   name: "My App",
 *   schemas: new EventSchemas().fromRecord<{
 *     "app/user.created": {
 *       data: { userId: string };
 *     };
 *   }>(),
 * });
 * ```
 *
 * @public
 */
export declare class Inngest<TOpts extends ClientOptions = ClientOptions> {
    #private;
    /**
     * The name of this instance, most commonly the name of the application it
     * resides in.
     */
    readonly name: string;
    /**
     * Inngest event key, used to send events to Inngest Cloud.
     */
    private eventKey;
    /**
     * Base URL for Inngest Cloud.
     */
    readonly inngestBaseUrl: URL;
    /**
     * The absolute URL of the Inngest Cloud API.
     */
    private inngestApiUrl;
    private readonly headers;
    private readonly fetch;
    private readonly logger;
    /**
     * A promise that resolves when the middleware stack has been initialized and
     * the client is ready to be used.
     */
    private readonly middleware;
    /**
     * A client used to interact with the Inngest API by sending or reacting to
     * events.
     *
     * To provide event typing, see {@link EventSchemas}.
     *
     * ```ts
     * const inngest = new Inngest({ name: "My App" });
     *
     * // or to provide event typing too
     * const inngest = new Inngest({
     *   name: "My App",
     *   schemas: new EventSchemas().fromRecord<{
     *     "app/user.created": {
     *       data: { userId: string };
     *     };
     *   }>(),
     * });
     * ```
     */
    constructor({ name, eventKey, inngestBaseUrl, fetch, env, logger, middleware, }: TOpts);
    /**
     * Initialize all passed middleware, running the `register` function on each
     * in sequence and returning the requested hook registrations.
     */
    private initializeMiddleware;
    /**
     * Set the event key for this instance of Inngest. This is useful if for some
     * reason the key is not available at time of instantiation or present in the
     * `INNGEST_EVENT_KEY` environment variable.
     */
    setEventKey(
    /**
     * Inngest event key, used to send events to Inngest Cloud. Use this is your
     * key is for some reason not available at time of instantiation or present
     * in the `INNGEST_EVENT_KEY` environment variable.
     */
    eventKey: string): void;
    /**
     * Send one or many events to Inngest. Takes an entire payload (including
     * name) as each input.
     *
     * ```ts
     * await inngest.send({ name: "app/user.created", data: { id: 123 } });
     * ```
     *
     * Returns a promise that will resolve if the event(s) were sent successfully,
     * else throws with an error explaining what went wrong.
     *
     * If you wish to send an event with custom types (i.e. one that hasn't been
     * generated), make sure to add it when creating your Inngest instance, like
     * so:
     *
     * ```ts
     * const inngest = new Inngest({
     *   name: "My App",
     *   schemas: new EventSchemas().fromRecord<{
     *     "my/event": {
     *       name: "my/event";
     *       data: { bar: string };
     *     };
     *   }>(),
     * });
     * ```
     */
    send<Payload extends SendEventPayload<EventsFromOpts<TOpts>>>(payload: Payload): Promise<void>;
    createFunction<TFns extends Record<string, unknown>, TMiddleware extends MiddlewareStack, TTrigger extends TriggerOptions<keyof EventsFromOpts<TOpts> & string>, TShimmedFns extends Record<string, (...args: any[]) => any> = ShimmedFns<TFns>, TTriggerName extends keyof EventsFromOpts<TOpts> & string = EventNameFromTrigger<EventsFromOpts<TOpts>, TTrigger>>(nameOrOpts: string | (Omit<FunctionOptions<EventsFromOpts<TOpts>, TTriggerName>, "fns" | "onFailure" | "middleware"> & {
        /**
         * Pass in an object of functions that will be wrapped in Inngest
         * tooling and passes to your handler. This wrapping ensures that each
         * function is automatically separated and retried.
         *
         * @example
         *
         * Both examples behave the same; it's preference as to which you
         * prefer.
         *
         * ```ts
         * import { userDb } from "./db";
         *
         * // Specify `fns` and be able to use them in your Inngest function
         * inngest.createFunction(
         *   { name: "Create user from PR", fns: { ...userDb } },
         *   { event: "github/pull_request" },
         *   async ({ fns: { createUser } }) => {
         *     await createUser("Alice");
         *   }
         * );
         *
         * // Or always use `run()` to run inline steps and use them directly
         * inngest.createFunction(
         *   { name: "Create user from PR" },
         *   { event: "github/pull_request" },
         *   async ({ step: { run } }) => {
         *     await run("createUser", () => userDb.createUser("Alice"));
         *   }
         * );
         * ```
         */
        fns?: TFns;
        /**
         * Provide a function to be called if your function fails, meaning
         * that it ran out of retries and was unable to complete successfully.
         *
         * This is useful for sending warning notifications or cleaning up
         * after a failure and supports all the same functionality as a
         * regular handler.
         */
        onFailure?: Handler<TOpts, EventsFromOpts<TOpts>, TTriggerName, TShimmedFns, FailureEventArgs<EventsFromOpts<TOpts>[TTriggerName]>>;
        /**
         * TODO
         */
        middleware?: TMiddleware;
    }), trigger: TTrigger, handler: Handler<TOpts, EventsFromOpts<TOpts>, TTriggerName, TShimmedFns, MiddlewareStackRunInputMutation<{}, typeof builtInMiddleware> & MiddlewareStackRunInputMutation<{}, NonNullable<TOpts["middleware"]>> & MiddlewareStackRunInputMutation<{}, TMiddleware>>): InngestFunction<TOpts, EventsFromOpts<TOpts>, FunctionTrigger<keyof EventsFromOpts<TOpts> & string>, FunctionOptions<EventsFromOpts<TOpts>, keyof EventsFromOpts<TOpts> & string>>;
}
/**
 * Default middleware that is included in every client, placed after the user's
 * middleware on the client but before function-level middleware.
 *
 * It is defined here to ensure that comments are included in the generated TS
 * definitions. Without this, we infer the stack of built-in middleware without
 * comments, losing a lot of value.
 *
 * If this is moved, please ensure that using this package in another project
 * can correctly access comments on mutated input and output.
 */
declare const builtInMiddleware: [InngestMiddleware<{
    name: string;
    init({ client }: {
        client: Inngest<any>;
        fn?: InngestFunction<any, any, any, any> | undefined;
    }): {
        onFunctionRun(arg: Readonly<import("type-fest").Simplify<Omit<Readonly<{
            ctx: Record<string, unknown> & Readonly<import("../types").BaseContext<ClientOptions, string, Record<string, (...args: unknown[]) => unknown>>>;
            steps: Readonly<Omit<{
                data?: any;
                error?: any;
                id: string;
            }, "id">>[];
            fn: InngestFunction<any, any, any, any>;
        }>, "ctx"> & {
            ctx: Pick<Record<string, unknown> & Readonly<import("../types").BaseContext<ClientOptions, string, Record<string, (...args: unknown[]) => unknown>>>, "event" | "runId">;
        }>>): {
            transformInput(): {
                ctx: {
                    /**
                     * The passed in logger from the user.
                     * Defaults to a console logger if not provided.
                     */
                    logger: Logger;
                };
            };
            beforeExecution(): void;
            transformOutput({ result: { error } }: {
                result: Readonly<Pick<import("../types").OutgoingOp, "data" | "error">>;
                step?: Readonly<Omit<import("../types").OutgoingOp, "id">> | undefined;
            }): void;
            beforeResponse(): Promise<void>;
        };
    };
}>];
export {};
//# sourceMappingURL=Inngest.d.ts.map