"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Inngest_instances, _Inngest_getResponseError;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Inngest = void 0;
const consts_1 = require("../helpers/consts");
const devserver_1 = require("../helpers/devserver");
const env_1 = require("../helpers/env");
const errors_1 = require("../helpers/errors");
const strings_1 = require("../helpers/strings");
const logger_1 = require("../middleware/logger");
const InngestFunction_1 = require("./InngestFunction");
const InngestMiddleware_1 = require("./InngestMiddleware");
/**
 * A client used to interact with the Inngest API by sending or reacting to
 * events.
 *
 * To provide event typing, see {@link EventSchemas}.
 *
 * ```ts
 * const inngest = new Inngest({ name: "My App" });
 *
 * // or to provide event typing too
 * const inngest = new Inngest({
 *   name: "My App",
 *   schemas: new EventSchemas().fromRecord<{
 *     "app/user.created": {
 *       data: { userId: string };
 *     };
 *   }>(),
 * });
 * ```
 *
 * @public
 */
class Inngest {
    /**
     * A client used to interact with the Inngest API by sending or reacting to
     * events.
     *
     * To provide event typing, see {@link EventSchemas}.
     *
     * ```ts
     * const inngest = new Inngest({ name: "My App" });
     *
     * // or to provide event typing too
     * const inngest = new Inngest({
     *   name: "My App",
     *   schemas: new EventSchemas().fromRecord<{
     *     "app/user.created": {
     *       data: { userId: string };
     *     };
     *   }>(),
     * });
     * ```
     */
    constructor({ name, eventKey, inngestBaseUrl = "https://inn.gs/", fetch, env, logger = new logger_1.DefaultLogger(), middleware, }) {
        _Inngest_instances.add(this);
        /**
         * Inngest event key, used to send events to Inngest Cloud.
         */
        this.eventKey = "";
        /**
         * The absolute URL of the Inngest Cloud API.
         */
        this.inngestApiUrl = new URL(`e/${this.eventKey}`, "https://inn.gs/");
        if (!name) {
            // TODO PrettyError
            throw new Error("A name must be passed to create an Inngest instance.");
        }
        this.name = name;
        this.inngestBaseUrl = new URL(inngestBaseUrl);
        this.setEventKey(eventKey || (0, env_1.processEnv)(consts_1.envKeys.EventKey) || "");
        if (!this.eventKey) {
            console.warn((0, errors_1.prettyError)({
                type: "warn",
                whatHappened: "Could not find event key",
                consequences: "Sending events will throw in production unless an event key is added.",
                toFixNow: errors_1.fixEventKeyMissingSteps,
                why: "We couldn't find an event key to use to send events to Inngest.",
                otherwise: "Create a new production event key at https://app.inngest.com/env/production/manage/keys.",
            }));
        }
        this.headers = (0, env_1.inngestHeaders)({
            inngestEnv: env,
        });
        this.fetch = (0, env_1.getFetch)(fetch);
        this.logger = logger;
        this.middleware = this.initializeMiddleware([
            ...builtInMiddleware,
            ...(middleware || []),
        ]);
    }
    /**
     * Initialize all passed middleware, running the `register` function on each
     * in sequence and returning the requested hook registrations.
     */
    async initializeMiddleware(middleware = [], opts) {
        var _a;
        /**
         * Wait for the prefix stack to run first; do not trigger ours before this
         * is complete.
         */
        const prefix = await ((_a = opts === null || opts === void 0 ? void 0 : opts.prefixStack) !== null && _a !== void 0 ? _a : []);
        const stack = middleware.reduce(async (acc, m) => {
            // Be explicit about waiting for the previous middleware to finish
            const prev = await acc;
            const next = await m.init(Object.assign({ client: this }, opts === null || opts === void 0 ? void 0 : opts.registerInput));
            return [...prev, next];
        }, Promise.resolve([]));
        return [...prefix, ...(await stack)];
    }
    /**
     * Set the event key for this instance of Inngest. This is useful if for some
     * reason the key is not available at time of instantiation or present in the
     * `INNGEST_EVENT_KEY` environment variable.
     */
    setEventKey(
    /**
     * Inngest event key, used to send events to Inngest Cloud. Use this is your
     * key is for some reason not available at time of instantiation or present
     * in the `INNGEST_EVENT_KEY` environment variable.
     */
    eventKey) {
        this.eventKey = eventKey;
        this.inngestApiUrl = new URL(`e/${this.eventKey}`, this.inngestBaseUrl);
    }
    /**
     * Send one or many events to Inngest. Takes an entire payload (including
     * name) as each input.
     *
     * ```ts
     * await inngest.send({ name: "app/user.created", data: { id: 123 } });
     * ```
     *
     * Returns a promise that will resolve if the event(s) were sent successfully,
     * else throws with an error explaining what went wrong.
     *
     * If you wish to send an event with custom types (i.e. one that hasn't been
     * generated), make sure to add it when creating your Inngest instance, like
     * so:
     *
     * ```ts
     * const inngest = new Inngest({
     *   name: "My App",
     *   schemas: new EventSchemas().fromRecord<{
     *     "my/event": {
     *       name: "my/event";
     *       data: { bar: string };
     *     };
     *   }>(),
     * });
     * ```
     */
    async send(payload) {
        var _a, _b;
        const hooks = await (0, InngestMiddleware_1.getHookStack)(this.middleware, "onSendEvent", undefined, {
            transformInput: (prev, output) => {
                return Object.assign(Object.assign({}, prev), output);
            },
            transformOutput: (prev, _output) => {
                return prev;
            },
        });
        if (!this.eventKey) {
            throw new Error((0, errors_1.prettyError)({
                whatHappened: "Failed to send event",
                consequences: "Your event or events were not sent to Inngest.",
                why: "We couldn't find an event key to use to send events to Inngest.",
                toFixNow: errors_1.fixEventKeyMissingSteps,
            }));
        }
        let payloads = Array.isArray(payload)
            ? payload
            : payload
                ? [payload]
                : [];
        const inputChanges = await ((_a = hooks.transformInput) === null || _a === void 0 ? void 0 : _a.call(hooks, {
            payloads: [...payloads],
        }));
        if (inputChanges === null || inputChanges === void 0 ? void 0 : inputChanges.payloads) {
            payloads = [...inputChanges.payloads];
        }
        /**
         * It can be valid for a user to send an empty list of events; if this
         * happens, show a warning that this may not be intended, but don't throw.
         */
        if (!payloads.length) {
            return console.warn((0, errors_1.prettyError)({
                type: "warn",
                whatHappened: "`inngest.send()` called with no events",
                reassurance: "This is not an error, but you may not have intended to do this.",
                consequences: "The returned promise will resolve, but no events have been sent to Inngest.",
                stack: true,
            }));
        }
        // When sending events, check if the dev server is available.  If so, use the
        // dev server.
        let url = this.inngestApiUrl.href;
        if (!(0, env_1.skipDevServer)()) {
            const host = (0, env_1.devServerHost)();
            // If the dev server host env var has been set we always want to use
            // the dev server - even if it's down.  Otherwise, optimistically use
            // it for non-prod services.
            if (host !== undefined || (await (0, devserver_1.devServerAvailable)(host, this.fetch))) {
                url = (0, devserver_1.devServerUrl)(host, `e/${this.eventKey}`).href;
            }
        }
        const response = await this.fetch(url, {
            method: "POST",
            body: (0, strings_1.stringify)(payloads),
            headers: Object.assign({}, this.headers),
        });
        if (response.status >= 200 && response.status < 300) {
            return void (await ((_b = hooks.transformOutput) === null || _b === void 0 ? void 0 : _b.call(hooks, { payloads: [...payloads] })));
        }
        throw await __classPrivateFieldGet(this, _Inngest_instances, "m", _Inngest_getResponseError).call(this, response);
    }
    createFunction(nameOrOpts, trigger, handler) {
        const sanitizedOpts = (typeof nameOrOpts === "string" ? { name: nameOrOpts } : nameOrOpts);
        return new InngestFunction_1.InngestFunction(this, sanitizedOpts, typeof trigger === "string" ? { event: trigger } : trigger, 
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any
        handler);
    }
}
exports.Inngest = Inngest;
_Inngest_instances = new WeakSet(), _Inngest_getResponseError = 
/**
 * Given a response from Inngest, relay the error to the caller.
 */
async function _Inngest_getResponseError(response) {
    let errorMessage = "Unknown error";
    switch (response.status) {
        case 401:
            errorMessage = "Event key Not Found";
            break;
        case 400:
            errorMessage = "Cannot process event payload";
            break;
        case 403:
            errorMessage = "Forbidden";
            break;
        case 404:
            errorMessage = "Event key not found";
            break;
        case 406:
            errorMessage = `${JSON.stringify(await response.json())}`;
            break;
        case 409:
        case 412:
            errorMessage = "Event transformation failed";
            break;
        case 413:
            errorMessage = "Event payload too large";
            break;
        case 500:
            errorMessage = "Internal server error";
            break;
    }
    return new Error(`Inngest API Error: ${response.status} ${errorMessage}`);
};
/**
 * Default middleware that is included in every client, placed after the user's
 * middleware on the client but before function-level middleware.
 *
 * It is defined here to ensure that comments are included in the generated TS
 * definitions. Without this, we infer the stack of built-in middleware without
 * comments, losing a lot of value.
 *
 * If this is moved, please ensure that using this package in another project
 * can correctly access comments on mutated input and output.
 */
const builtInMiddleware = ((m) => m)([
    new InngestMiddleware_1.InngestMiddleware({
        name: "Inngest: Logger",
        init({ client }) {
            return {
                onFunctionRun(arg) {
                    const { ctx } = arg;
                    const metadata = {
                        runID: ctx.runId,
                        eventName: ctx.event.name,
                        functionName: arg.fn.name,
                    };
                    let providedLogger = client["logger"];
                    // create a child logger if the provided logger has child logger implementation
                    try {
                        if ("child" in providedLogger) {
                            providedLogger = providedLogger.child(metadata);
                        }
                    }
                    catch (err) {
                        console.error('failed to create "childLogger" with error: ', err);
                        // no-op
                    }
                    const logger = new logger_1.ProxyLogger(providedLogger);
                    return {
                        transformInput() {
                            return {
                                ctx: {
                                    /**
                                     * The passed in logger from the user.
                                     * Defaults to a console logger if not provided.
                                     */
                                    logger: logger,
                                },
                            };
                        },
                        beforeExecution() {
                            logger.enable();
                        },
                        transformOutput({ result: { error } }) {
                            if (error) {
                                logger.error(error);
                            }
                        },
                        async beforeResponse() {
                            await logger.flush();
                        },
                    };
                },
            };
        },
    }),
]);
//# sourceMappingURL=Inngest.js.map