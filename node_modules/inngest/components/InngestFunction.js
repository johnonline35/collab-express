"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var _InngestFunction_instances, _InngestFunction_fn, _InngestFunction_onFailureFn, _InngestFunction_client, _InngestFunction_generateId;
Object.defineProperty(exports, "__esModule", { value: true });
exports.createExecutionState = exports.InngestFunction = void 0;
const zod_1 = require("zod");
const consts_1 = require("../helpers/consts");
const errors_1 = require("../helpers/errors");
const promises_1 = require("../helpers/promises");
const strings_1 = require("../helpers/strings");
const types_1 = require("../types");
const InngestMiddleware_1 = require("./InngestMiddleware");
const InngestStepTools_1 = require("./InngestStepTools");
const NonRetriableError_1 = require("./NonRetriableError");
/**
 * A stateless Inngest function, wrapping up function configuration and any
 * in-memory steps to run when triggered.
 *
 * This function can be "registered" to create a handler that Inngest can
 * trigger remotely.
 *
 * @public
 */
class InngestFunction {
    /**
     * A stateless Inngest function, wrapping up function configuration and any
     * in-memory steps to run when triggered.
     *
     * This function can be "registered" to create a handler that Inngest can
     * trigger remotely.
     */
    constructor(client, 
    /**
     * Options
     */
    opts, trigger, fn) {
        _InngestFunction_instances.add(this);
        _InngestFunction_fn.set(this, void 0);
        _InngestFunction_onFailureFn.set(this, void 0);
        _InngestFunction_client.set(this, void 0);
        __classPrivateFieldSet(this, _InngestFunction_client, client, "f");
        this.opts = opts;
        this.trigger = trigger;
        __classPrivateFieldSet(this, _InngestFunction_fn, fn, "f");
        __classPrivateFieldSet(this, _InngestFunction_onFailureFn, this.opts.onFailure, "f");
        this.middleware = __classPrivateFieldGet(this, _InngestFunction_client, "f")["initializeMiddleware"](this.opts.middleware, { registerInput: { fn: this }, prefixStack: __classPrivateFieldGet(this, _InngestFunction_client, "f")["middleware"] });
    }
    /**
     * The generated or given ID for this function.
     */
    id(prefix) {
        return this.opts.id || __classPrivateFieldGet(this, _InngestFunction_instances, "m", _InngestFunction_generateId).call(this, prefix);
    }
    /**
     * The name of this function as it will appear in the Inngest Cloud UI.
     */
    get name() {
        return this.opts.name;
    }
    /**
     * Retrieve the Inngest config for this function.
     */
    getConfig(
    /**
     * Must be provided a URL that will be used to access the function and step.
     * This function can't be expected to know how it will be accessed, so
     * relies on an outside method providing context.
     */
    baseUrl, appPrefix) {
        const fnId = this.id(appPrefix);
        const stepUrl = new URL(baseUrl.href);
        stepUrl.searchParams.set(consts_1.queryKeys.FnId, fnId);
        stepUrl.searchParams.set(consts_1.queryKeys.StepId, InngestFunction.stepId);
        const _a = this.opts, { retries: attempts, cancelOn, fns: _ } = _a, opts = __rest(_a, ["retries", "cancelOn", "fns"]);
        /**
         * Convert retries into the format required when defining function
         * configuration.
         */
        const retries = typeof attempts === "undefined" ? undefined : { attempts };
        const fn = Object.assign(Object.assign({}, opts), { id: fnId, name: this.name, triggers: [this.trigger], steps: {
                [InngestFunction.stepId]: {
                    id: InngestFunction.stepId,
                    name: InngestFunction.stepId,
                    runtime: {
                        type: "http",
                        url: stepUrl.href,
                    },
                    retries,
                },
            } });
        if (cancelOn) {
            fn.cancel = cancelOn.map(({ event, timeout, if: ifStr, match }) => {
                const ret = {
                    event,
                };
                if (timeout) {
                    ret.timeout = (0, strings_1.timeStr)(timeout);
                }
                if (match) {
                    ret.if = `event.${match} == async.${match}`;
                }
                else if (ifStr) {
                    ret.if = ifStr;
                }
                return ret;
            }, []);
        }
        const config = [fn];
        if (__classPrivateFieldGet(this, _InngestFunction_onFailureFn, "f")) {
            const failureOpts = Object.assign({}, opts);
            const id = `${fn.id}${InngestFunction.failureSuffix}`;
            const name = `${fn.name} (failure)`;
            const failureStepUrl = new URL(stepUrl.href);
            failureStepUrl.searchParams.set(consts_1.queryKeys.FnId, id);
            config.push(Object.assign(Object.assign({}, failureOpts), { id,
                name, triggers: [
                    {
                        event: consts_1.internalEvents.FunctionFailed,
                        expression: `event.data.function_id == '${fnId}'`,
                    },
                ], steps: {
                    [InngestFunction.stepId]: {
                        id: InngestFunction.stepId,
                        name: InngestFunction.stepId,
                        runtime: {
                            type: "http",
                            url: failureStepUrl.href,
                        },
                        retries: { attempts: 1 },
                    },
                } }));
        }
        return config;
    }
    /**
     * Run this function, optionally providing an op stack to pass as state.
     *
     * It is a `private` method to prevent users from being exposed to it
     * directly, but ensuring it is available to the generated handler.
     *
     * For a single-step function that doesn't use any step tooling, this will
     * await the result of the function given to this instance of
     * `InngestFunction` and return the data and a boolean indicating that the
     * function is complete and should not be called again.
     *
     * For a multi-step function, also try to await the result of the function
     * given to this instance of `InngestFunction`, though will check whether an
     * op has been submitted for use (or a Promise is pending, such as a step
     * running) after the function has completed.
     */
    async runFn(
    /**
     * The data to pass to the function, probably straight from Inngest.
     */
    data, 
    /**
     * The op stack to pass to the function as state, likely stored in
     * `ctx._state` in the Inngest payload.
     *
     * This must be provided in order to always be cognizant of step function
     * state and to allow for multi-step functions.
     */
    opStack, 
    /**
     * The step ID that Inngest wants to run and receive data from. If this is
     * defined, the step's user code will be run after filling the op stack. If
     * this is `null`, the function will be run and next operations will be
     * returned instead.
     */
    requestedRunStep, timer, 
    /**
     * TODO Ugly boolean option; wrap this.
     */
    isFailureHandler) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const ctx = data;
        const hookStack = await (0, InngestMiddleware_1.getHookStack)(this.middleware, "onFunctionRun", { ctx, fn: this, steps: opStack }, {
            transformInput: (prev, output) => {
                return {
                    ctx: Object.assign(Object.assign({}, prev.ctx), output === null || output === void 0 ? void 0 : output.ctx),
                    fn: this,
                    steps: prev.steps.map((step, i) => {
                        var _a;
                        return (Object.assign(Object.assign({}, step), (_a = output === null || output === void 0 ? void 0 : output.steps) === null || _a === void 0 ? void 0 : _a[i]));
                    }),
                };
            },
            transformOutput: (prev, output) => {
                return {
                    result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),
                    step: prev.step,
                };
            },
        });
        const createFinalError = async (err, step) => {
            var _a;
            await ((_a = hookStack.afterExecution) === null || _a === void 0 ? void 0 : _a.call(hookStack));
            const result = {
                error: err,
            };
            try {
                result.data = (0, errors_1.serializeError)(err);
            }
            catch (serializationErr) {
                console.warn("Could not serialize error to return to Inngest; stringifying instead", serializationErr);
                result.data = err;
            }
            const hookOutput = await applyHookToOutput(hookStack.transformOutput, {
                result,
                step,
            });
            return new errors_1.OutgoingResultError(hookOutput);
        };
        const state = (0, exports.createExecutionState)();
        const memoizingStop = timer.start("memoizing");
        /**
         * Create some values to be mutated and passed to the step tools. Once the
         * user's function has run, we can check the mutated state of these to see
         * if an op has been submitted or not.
         */
        const step = (0, InngestStepTools_1.createStepTools)(__classPrivateFieldGet(this, _InngestFunction_client, "f"), state);
        try {
            /**
             * Create args to pass in to our function. We blindly pass in the data and
             * add tools.
             */
            let fnArg = Object.assign(Object.assign({}, data), { step });
            let userFnToRun = __classPrivateFieldGet(this, _InngestFunction_fn, "f");
            /**
             * If the incoming event is an Inngest function failure event, we also want
             * to pass some extra data to the function to act as shortcuts to the event
             * payload.
             */
            if (isFailureHandler) {
                /**
                 * The user could have created a function that intentionally listens for
                 * these events. In this case, we may want to use the original handler.
                 *
                 * We only use the onFailure handler if
                 */
                if (!__classPrivateFieldGet(this, _InngestFunction_onFailureFn, "f")) {
                    // TODO PrettyError
                    throw new Error(`Function "${this.name}" received a failure event to handle, but no failure handler was defined.`);
                }
                userFnToRun = __classPrivateFieldGet(this, _InngestFunction_onFailureFn, "f");
                const eventData = zod_1.z
                    .object({ error: types_1.failureEventErrorSchema })
                    .parse((_a = fnArg.event) === null || _a === void 0 ? void 0 : _a.data);
                fnArg = Object.assign(Object.assign({}, fnArg), { error: (0, errors_1.deserializeError)(eventData.error) });
            }
            /**
             * If the user has passed functions they wish to use in their step, add them
             * here.
             *
             * We simply place a thin `tools.run()` wrapper around the function and
             * nothing else.
             */
            if (this.opts.fns) {
                fnArg.fns = Object.entries(this.opts.fns).reduce((acc, [key, fn]) => {
                    if (typeof fn !== "function") {
                        return acc;
                    }
                    return Object.assign(Object.assign({}, acc), { 
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call
                        [key]: (...args) => step.run(key, () => fn(...args)) });
                }, {});
            }
            const inputMutations = await ((_b = hookStack.transformInput) === null || _b === void 0 ? void 0 : _b.call(hookStack, {
                ctx: Object.assign({}, fnArg),
                steps: opStack,
                fn: this,
            }));
            if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.ctx) {
                fnArg = inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.ctx;
            }
            if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.steps) {
                opStack = inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.steps;
            }
            await ((_c = hookStack.beforeMemoization) === null || _c === void 0 ? void 0 : _c.call(hookStack));
            if (opStack.length === 0 && !requestedRunStep) {
                await ((_d = hookStack.afterMemoization) === null || _d === void 0 ? void 0 : _d.call(hookStack));
                await ((_e = hookStack.beforeExecution) === null || _e === void 0 ? void 0 : _e.call(hookStack));
            }
            // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor
            const userFnPromise = new Promise(async (resolve, reject) => {
                try {
                    resolve(await userFnToRun(fnArg));
                }
                catch (err) {
                    // logger.error(err);
                    reject(err);
                }
            });
            let pos = -1;
            do {
                if (pos >= 0) {
                    if (!requestedRunStep && pos == opStack.length - 1) {
                        await ((_f = hookStack.afterMemoization) === null || _f === void 0 ? void 0 : _f.call(hookStack));
                        await ((_g = hookStack.beforeExecution) === null || _g === void 0 ? void 0 : _g.call(hookStack));
                    }
                    state.tickOps = {};
                    const incomingOp = opStack[pos];
                    state.currentOp = state.allFoundOps[incomingOp.id];
                    if (!state.currentOp) {
                        /**
                         * We're trying to resume the function, but we can't find where to go.
                         *
                         * This means that either the function has changed or there are async
                         * actions in-between steps that we haven't noticed in previous
                         * executions.
                         *
                         * Whichever the case, this is bad and we can't continue in this
                         * undefined state.
                         */
                        throw new NonRetriableError_1.NonRetriableError((0, errors_1.functionStoppedRunningErr)(errors_1.ErrCode.ASYNC_DETECTED_DURING_MEMOIZATION));
                    }
                    state.currentOp.fulfilled = true;
                    if (typeof incomingOp.data !== "undefined") {
                        state.currentOp.resolve(incomingOp.data);
                    }
                    else {
                        state.currentOp.reject(incomingOp.error);
                    }
                }
                await timer.wrap("memoizing-ticks", promises_1.resolveAfterPending);
                state.reset();
                pos++;
            } while (pos < opStack.length);
            memoizingStop();
            await ((_h = hookStack.afterMemoization) === null || _h === void 0 ? void 0 : _h.call(hookStack));
            const discoveredOps = Object.values(state.tickOps).map(tickOpToOutgoing);
            /**
             * We make an optimization here by immediately invoking an op if it's the
             * only one we've discovered. The alternative is to plan the step and then
             * complete it, so we skip at least one entire execution with this.
             */
            const runStep = requestedRunStep || getEarlyExecRunStep(discoveredOps);
            if (runStep) {
                const userFnOp = state.allFoundOps[runStep];
                const userFnToRun = userFnOp === null || userFnOp === void 0 ? void 0 : userFnOp.fn;
                if (!userFnToRun) {
                    // TODO PrettyError
                    throw new Error(`Bad stack; executor requesting to run unknown step "${runStep}"`);
                }
                const outgoingUserFnOp = Object.assign(Object.assign({}, tickOpToOutgoing(userFnOp)), { op: types_1.StepOpCode.RunStep });
                await ((_j = hookStack.beforeExecution) === null || _j === void 0 ? void 0 : _j.call(hookStack));
                const runningStepStop = timer.start("running-step");
                state.executingStep = true;
                const result = await new Promise((resolve) => {
                    return resolve(userFnToRun());
                })
                    .finally(() => {
                    state.executingStep = false;
                    runningStepStop();
                })
                    .catch(async (err) => {
                    return await createFinalError(err, outgoingUserFnOp);
                })
                    .then(async (data) => {
                    var _a;
                    await ((_a = hookStack.afterExecution) === null || _a === void 0 ? void 0 : _a.call(hookStack));
                    return await applyHookToOutput(hookStack.transformOutput, {
                        result: { data: typeof data === "undefined" ? null : data },
                        step: outgoingUserFnOp,
                    });
                });
                return ["run", Object.assign(Object.assign({}, outgoingUserFnOp), result)];
            }
            /**
             * Now we're here, we've memoised any function state and we know that this
             * request was a discovery call to find out next steps.
             *
             * We've already given the user's function a lot of chance to register any
             * more ops, so we can assume that this list of discovered ops is final.
             *
             * With that in mind, if this list is empty AND we haven't previously used
             * any step tools, we can assume that the user's function is not one that'll
             * be using step tooling, so we'll just wait for it to complete and return
             * the result.
             *
             * An empty list while also using step tooling is a valid state when the end
             * of a chain of promises is reached, so we MUST also check if step tooling
             * has previously been used.
             */
            if (!discoveredOps.length) {
                const fnRet = await Promise.race([
                    userFnPromise.then((data) => ({ type: "complete", data })),
                    (0, promises_1.resolveNextTick)().then(() => ({ type: "incomplete" })),
                ]);
                if (fnRet.type === "complete") {
                    await ((_k = hookStack.afterExecution) === null || _k === void 0 ? void 0 : _k.call(hookStack));
                    /**
                     * The function has returned a value, so we should return this to
                     * Inngest. Doing this will cause the function to be marked as
                     * complete, so we should only do this if we're sure that all
                     * registered ops have been resolved.
                     */
                    const allOpsFulfilled = Object.values(state.allFoundOps).every((op) => {
                        return op.fulfilled;
                    });
                    if (allOpsFulfilled) {
                        const result = await applyHookToOutput(hookStack.transformOutput, {
                            result: { data: fnRet.data },
                        });
                        return ["complete", result.data];
                    }
                    /**
                     * If we're here, it means that the user's function has returned a
                     * value but not all ops have been resolved. This might be intentional
                     * if they are purposefully pushing work to the background, but also
                     * might be unintentional and a bug in the user's code where they
                     * expected an order to be maintained.
                     *
                     * To be safe, we'll show a warning here to tell users that this might
                     * be unintentional, but otherwise carry on as normal.
                     */
                    // TODO PrettyError
                    console.warn(`Warning: Your "${this.name}" function has returned a value, but not all ops have been resolved, i.e. you have used step tooling without \`await\`. This may be intentional, but if you expect your ops to be resolved in order, you should \`await\` them. If you are knowingly leaving ops unresolved using \`.catch()\` or \`void\`, you can ignore this warning.`);
                }
                else if (!state.hasUsedTools) {
                    /**
                     * If we're here, it means that the user's function has not returned
                     * a value, but also has not used step tooling. This is a valid
                     * state, indicating that the function is a single-action async
                     * function.
                     *
                     * We should wait for the result and return it.
                     *
                     * A caveat here is that the user could use step tooling later on,
                     * resulting in a mix of step and non-step logic. This is not something
                     * we want to support without an opt-in from the user, so we should
                     * throw if this is the case.
                     */
                    state.nonStepFnDetected = true;
                    const data = await userFnPromise;
                    await ((_l = hookStack.afterExecution) === null || _l === void 0 ? void 0 : _l.call(hookStack));
                    const { data: result } = await applyHookToOutput(hookStack.transformOutput, {
                        result: { data },
                    });
                    return ["complete", result];
                }
                else {
                    /**
                     * If we're here, the user's function has not returned a value, has not
                     * reported any new ops, but has also previously used step tools and
                     * successfully memoized state.
                     *
                     * This indicates that the user has mixed step and non-step logic, which
                     * is not something we want to support without an opt-in from the user.
                     *
                     * We should throw here to let the user know that this is not supported.
                     *
                     * We need to be careful, though; it's a valid state for a chain of
                     * promises to return no further actions, so we should only throw if
                     * this state is reached and there are no other pending steps.
                     */
                    const hasOpsPending = Object.values(state.allFoundOps).some((op) => {
                        return op.fulfilled === false;
                    });
                    if (!hasOpsPending) {
                        throw new NonRetriableError_1.NonRetriableError((0, errors_1.functionStoppedRunningErr)(errors_1.ErrCode.ASYNC_DETECTED_AFTER_MEMOIZATION));
                    }
                }
            }
            await ((_m = hookStack.afterExecution) === null || _m === void 0 ? void 0 : _m.call(hookStack));
            return ["discovery", discoveredOps];
        }
        catch (err) {
            throw await createFinalError(err);
        }
        finally {
            await ((_o = hookStack.beforeResponse) === null || _o === void 0 ? void 0 : _o.call(hookStack));
        }
    }
}
_InngestFunction_fn = new WeakMap(), _InngestFunction_onFailureFn = new WeakMap(), _InngestFunction_client = new WeakMap(), _InngestFunction_instances = new WeakSet(), _InngestFunction_generateId = function _InngestFunction_generateId(prefix) {
    return (0, strings_1.slugify)([prefix || "", this.opts.name].join("-"));
};
InngestFunction.stepId = "step";
InngestFunction.failureSuffix = "-failure";
exports.InngestFunction = InngestFunction;
const tickOpToOutgoing = (op) => {
    return {
        op: op.op,
        id: op.id,
        name: op.name,
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        opts: op.opts,
    };
};
/**
 * Given the list of outgoing ops, decide if we can execute an op early and
 * return the ID of the step to run if we can.
 */
const getEarlyExecRunStep = (ops) => {
    if (ops.length !== 1)
        return;
    const op = ops[0];
    if (op &&
        op.op === types_1.StepOpCode.StepPlanned &&
        typeof op.opts === "undefined") {
        return op.id;
    }
};
const createExecutionState = () => {
    const state = {
        allFoundOps: {},
        tickOps: {},
        tickOpHashes: {},
        currentOp: undefined,
        hasUsedTools: false,
        reset: () => {
            state.tickOpHashes = {};
            state.allFoundOps = Object.assign(Object.assign({}, state.allFoundOps), state.tickOps);
        },
        nonStepFnDetected: false,
        executingStep: false,
    };
    return state;
};
exports.createExecutionState = createExecutionState;
const applyHookToOutput = async (outputHook, arg) => {
    const hookOutput = await (outputHook === null || outputHook === void 0 ? void 0 : outputHook(arg));
    return Object.assign(Object.assign({}, arg.result), hookOutput === null || hookOutput === void 0 ? void 0 : hookOutput.result);
};
//# sourceMappingURL=InngestFunction.js.map