"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InngestCommHandler = void 0;
const canonicalize_1 = __importDefault(require("canonicalize"));
const hash_js_1 = require("hash.js");
const zod_1 = require("zod");
const ServerTiming_1 = require("../helpers/ServerTiming");
const consts_1 = require("../helpers/consts");
const devserver_1 = require("../helpers/devserver");
const env_1 = require("../helpers/env");
const errors_1 = require("../helpers/errors");
const functions_1 = require("../helpers/functions");
const scalar_1 = require("../helpers/scalar");
const stream_1 = require("../helpers/stream");
const strings_1 = require("../helpers/strings");
const landing_1 = require("../landing");
const version_1 = require("../version");
const NonRetriableError_1 = require("./NonRetriableError");
/**
 * A schema for the response from Inngest when registering.
 */
const registerResSchema = zod_1.z.object({
    status: zod_1.z.number().default(200),
    skipped: zod_1.z.boolean().optional().default(false),
    error: zod_1.z.string().default("Successfully registered"),
});
/**
 * `InngestCommHandler` is a class for handling incoming requests from Inngest (or
 * Inngest's tooling such as the dev server or CLI) and taking appropriate
 * action for any served functions.
 *
 * All handlers (Next.js, RedwoodJS, Remix, Deno Fresh, etc) are created using
 * this class; the exposed `serve` function will - most commonly - create an
 * instance of `InngestCommHandler` and then return `instance.createHandler()`.
 *
 * Two critical parameters required are the `handler` and the `transformRes`
 * function. See individual parameter details for more information, or see the
 * source code for an existing handler, e.g.
 * {@link https://github.com/inngest/inngest-js/blob/main/src/next.ts}
 *
 * @example
 * ```
 * // my-custom-handler.ts
 * import { InngestCommHandler, ServeHandler } from "inngest";
 *
 * export const serve: ServeHandler = (nameOrInngest, fns, opts) => {
 *   const handler = new InngestCommHandler(
 *     "my-custom-handler",
 *     nameOrInngest,
 *     fns,
 *     opts,
 *     () => { ... },
 *     () => { ... }
 *   );
 *
 *   return handler.createHandler();
 * };
 * ```
 *
 * @public
 */
class InngestCommHandler {
    constructor(
    /**
     * The name of the framework this handler is designed for. Should be
     * lowercase, alphanumeric characters inclusive of `-` and `/`.
     *
     * This should never be defined by the user; a {@link ServeHandler} should
     * abstract this.
     */
    frameworkName, 
    /**
     * The name of this serve handler, e.g. `"My App"`. It's recommended that this
     * value represents the overarching app/service that this set of functions is
     * being served from.
     *
     * This can also be an `Inngest` client, in which case the name given when
     * instantiating the client is used. This is useful if you're sending and
     * receiving events from the same service, as you can reuse a single
     * definition of Inngest.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    client, 
    /**
     * An array of the functions to serve and register with Inngest.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    functions, { inngestRegisterUrl, fetch, landingPage, logLevel = "info", signingKey, serveHost, servePath, streaming, name, } = {}, 
    /**
     * The `handler` is the function your framework requires to handle a
     * request. For example, this is most commonly a function that is given a
     * `Request` and must return a `Response`.
     *
     * The handler must map out any incoming parameters, then return a
     * strictly-typed object to assess what kind of request is being made,
     * collecting any relevant data as we go.
     *
     * @example
     * ```
     * return {
     *   register: () => { ... },
     *   run: () => { ... },
     *   view: () => { ... }
     * };
     * ```
     *
     * Every key must be specified and must be a function that either returns
     * a strictly-typed payload or `undefined` if the request is not for that
     * purpose.
     *
     * This gives handlers freedom to choose how their platform of choice will
     * trigger differing actions, whilst also ensuring all required information
     * is given for each request type.
     *
     * See any existing handler for a full example.
     *
     * This should never be defined by the user; a {@link ServeHandler} should
     * abstract this.
     */
    handler, 
    /**
     * The `transformRes` function receives the output of the Inngest SDK and
     * can decide how to package up that information to appropriately return the
     * information to Inngest.
     *
     * Mostly, this is taking the given parameters and returning a new
     * `Response`.
     *
     * The function is passed an {@link ActionResponse} (an object containing a
     * `status` code, a `headers` object, and a stringified `body`), as well as
     * every parameter passed to the given `handler` function. This ensures you
     * can appropriately handle the response, including use of any required
     * parameters such as `res` in Express-/Connect-like frameworks.
     *
     * This should never be defined by the user; a {@link ServeHandler} should
     * abstract this.
     */
    transformRes, 
    /**
     * The `streamTransformRes` function, if defined, declares that this handler
     * supports streaming responses back to Inngest. This is useful for
     * functions that are expected to take a long time, as edge streaming can
     * often circumvent restrictive request timeouts and other limitations.
     *
     * If your handler does not support streaming, do not define this function.
     *
     * It receives the output of the Inngest SDK and can decide how to package
     * up that information to appropriately return the information in a stream
     * to Inngest.
     *
     * Mostly, this is taking the given parameters and returning a new
     * `Response`.
     *
     * The function is passed an {@link ActionResponse} (an object containing a
     * `status` code, a `headers` object, and `body`, a `ReadableStream`), as
     * well as every parameter passed to the given `handler` function. This
     * ensures you can appropriately handle the response, including use of any
     * required parameters such as `res` in Express-/Connect-like frameworks.
     *
     * This should never be defined by the user; a {@link ServeHandler} should
     * abstract this.
     */
    streamTransformRes) {
        var _a;
        /**
         * A property that can be set to indicate whether or not we believe we are in
         * production mode.
         *
         * Should be set every time a request is received.
         */
        this._isProd = false;
        /**
         * Whether we should attempt to use the dev server.
         *
         * Should be set every time a request is received.
         */
        this._skipDevServer = false;
        /**
         * A private collection of functions that are being served. This map is used
         * to find and register functions when interacting with Inngest Cloud.
         */
        this.fns = {};
        this.frameworkName = frameworkName;
        this.client = client;
        this.name = name || this.client.name;
        this.handler = handler;
        this.transformRes = transformRes;
        this.streamTransformRes = streamTransformRes;
        /**
         * Provide a hidden option to allow expired signatures to be accepted during
         * testing.
         */
        this.allowExpiredSignatures = Boolean(
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, prefer-rest-params
        (_a = arguments["3"]) === null || _a === void 0 ? void 0 : _a.__testingAllowExpiredSignatures);
        // Ensure we filter any undefined functions in case of missing imports.
        this.rawFns = functions.filter(Boolean);
        if (this.rawFns.length !== functions.length) {
            // TODO PrettyError
            console.warn(`Some functions passed to serve() are undefined and misconfigured.  Please check your imports.`);
        }
        this.fns = this.rawFns.reduce((acc, fn) => {
            const configs = fn["getConfig"](new URL("https://example.com"), this.name);
            const fns = configs.reduce((acc, { id }, index) => {
                return Object.assign(Object.assign({}, acc), { [id]: { fn, onFailure: Boolean(index) } });
            }, {});
            configs.forEach(({ id }) => {
                if (acc[id]) {
                    // TODO PrettyError
                    throw new Error(`Duplicate function ID "${id}"; please change a function's name or provide an explicit ID to avoid conflicts.`);
                }
            });
            return Object.assign(Object.assign({}, acc), fns);
        }, {});
        this.inngestRegisterUrl = new URL(inngestRegisterUrl || "https://api.inngest.com/fn/register");
        this.signingKey = signingKey;
        this.showLandingPage = landingPage;
        this.serveHost = serveHost;
        this.servePath = servePath;
        this.logLevel = logLevel;
        this.streaming = streaming !== null && streaming !== void 0 ? streaming : false;
        this.fetch = (0, env_1.getFetch)(fetch || this.client["fetch"]);
    }
    // hashedSigningKey creates a sha256 checksum of the signing key with the
    // same signing key prefix.
    get hashedSigningKey() {
        var _a;
        if (!this.signingKey) {
            return "";
        }
        const prefix = ((_a = this.signingKey.match(/^signkey-[\w]+-/)) === null || _a === void 0 ? void 0 : _a.shift()) || "";
        const key = this.signingKey.replace(/^signkey-[\w]+-/, "");
        // Decode the key from its hex representation into a bytestream
        return `${prefix}${(0, hash_js_1.sha256)().update(key, "hex").digest("hex")}`;
    }
    /**
     * `createHandler` should be used to return a type-equivalent version of the
     * `handler` specified during instantiation.
     *
     * @example
     * ```
     * // my-custom-handler.ts
     * import { InngestCommHandler, ServeHandler } from "inngest";
     *
     * export const serve: ServeHandler = (nameOrInngest, fns, opts) => {
     *   const handler = new InngestCommHandler(
     *     "my-custom-handler",
     *     nameOrInngest,
     *     fns,
     *     opts,
     *     () => { ... },
     *     () => { ... }
     *   );
     *
     *   return handler.createHandler();
     * };
     * ```
     */
    createHandler() {
        return async (...args) => {
            const timer = new ServerTiming_1.ServerTiming();
            /**
             * We purposefully `await` the handler, as it could be either sync or
             * async.
             */
            // eslint-disable-next-line @typescript-eslint/await-thenable
            const rawActions = await timer.wrap("handler", () => this.handler(...args));
            /**
             * For each function within the actions returned, ensure that its value
             * caches when run. This ensures that the function is only run once, even
             * if it's called multiple times throughout this handler's invocation.
             *
             * Many frameworks have issues with multiple calls to req/res objects;
             * reading a request's body multiple times is a common example. This makes
             * sure to handle this without having to pass around references.
             */
            const actions = Object.fromEntries(Object.entries(rawActions).map(([key, val]) => [
                key,
                typeof val === "function" ? (0, functions_1.cacheFn)(val) : val,
            ]));
            const getHeaders = () => (0, env_1.inngestHeaders)({
                env: actions.env,
                framework: this.frameworkName,
                client: this.client,
                extras: {
                    "Server-Timing": timer.getHeader(),
                },
            });
            const actionRes = timer.wrap("action", () => this.handleAction(actions, timer));
            /**
             * Prepares an action response by merging returned data to provide
             * trailing information such as `Server-Timing` headers.
             *
             * It should always prioritize the headers returned by the action, as
             * they may contain important information such as `Content-Type`.
             */
            const prepareActionRes = (res) => (Object.assign(Object.assign({}, res), { headers: Object.assign(Object.assign({}, getHeaders()), res.headers) }));
            const wantToStream = this.streaming === "force" ||
                (this.streaming === "allow" &&
                    (0, env_1.platformSupportsStreaming)(this.frameworkName, actions.env));
            if (wantToStream && this.streamTransformRes) {
                const runRes = await actions.run();
                if (runRes) {
                    const { stream, finalize } = await (0, stream_1.createStream)();
                    /**
                     * Errors are handled by `handleAction` here to ensure that an
                     * appropriate response is always given.
                     */
                    void actionRes.then((res) => finalize(prepareActionRes(res)));
                    return timer.wrap("res", () => {
                        var _a;
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                        return (_a = this.streamTransformRes) === null || _a === void 0 ? void 0 : _a.call(this, {
                            status: 201,
                            headers: getHeaders(),
                            body: stream,
                        }, ...args);
                    });
                }
            }
            return timer.wrap("res", async () => {
                return actionRes.then((res) => {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                    return this.transformRes(prepareActionRes(res), ...args);
                });
            });
        };
    }
    /**
     * Given a set of functions to check if an action is available from the
     * instance's handler, enact any action that is found.
     *
     * This method can fetch varying payloads of data, but ultimately is the place
     * where _decisions_ are made regarding functionality.
     *
     * For example, if we find that we should be viewing the UI, this function
     * will decide whether the UI should be visible based on the payload it has
     * found (e.g. env vars, options, etc).
     */
    async handleAction(actions, timer) {
        var _a, _b, _c;
        const env = (_a = actions.env) !== null && _a !== void 0 ? _a : (0, env_1.allProcessEnv)();
        const getHeaders = () => (0, env_1.inngestHeaders)({
            env: env,
            framework: this.frameworkName,
            client: this.client,
            extras: {
                "Server-Timing": timer.getHeader(),
            },
        });
        this._isProd = (_b = actions.isProduction) !== null && _b !== void 0 ? _b : (0, env_1.isProd)(env);
        // If we're in production always skip.
        this._skipDevServer = (_c = this._isProd) !== null && _c !== void 0 ? _c : (0, env_1.skipDevServer)(env);
        try {
            const runRes = await actions.run();
            if (runRes) {
                this.upsertSigningKeyFromEnv(env);
                this.validateSignature(runRes.signature, runRes.data);
                const stepRes = await this.runStep(runRes.fnId, runRes.stepId, runRes.data, timer);
                if (stepRes.status === 500 || stepRes.status === 400) {
                    return {
                        status: stepRes.status,
                        body: (0, strings_1.stringify)(stepRes.error ||
                            (0, errors_1.serializeError)(new Error("Unknown error; function failed but no error was returned"))),
                        headers: {
                            "Content-Type": "application/json",
                        },
                    };
                }
                return {
                    status: stepRes.status,
                    body: (0, strings_1.stringify)(stepRes.body),
                    headers: {
                        "Content-Type": "application/json",
                    },
                };
            }
            const viewRes = await actions.view();
            if (viewRes) {
                this.upsertSigningKeyFromEnv(env);
                const showLandingPage = this.shouldShowLandingPage((0, strings_1.stringifyUnknown)(env[consts_1.envKeys.LandingPage]));
                if (this._isProd || !showLandingPage) {
                    return {
                        status: 403,
                        body: JSON.stringify({
                            message: "Landing page requested but is disabled",
                            isProd: this._isProd,
                            skipDevServer: this._skipDevServer,
                            showLandingPage,
                        }),
                        headers: {},
                    };
                }
                if (viewRes.isIntrospection) {
                    const introspection = Object.assign(Object.assign({}, this.registerBody(this.reqUrl(actions.url))), { devServerURL: (0, devserver_1.devServerUrl)((0, strings_1.stringifyUnknown)(env[consts_1.envKeys.DevServerUrl])).href, hasSigningKey: Boolean(this.signingKey) });
                    return {
                        status: 200,
                        body: (0, strings_1.stringify)(introspection),
                        headers: {
                            "Content-Type": "application/json",
                        },
                    };
                }
                return {
                    status: 200,
                    body: landing_1.landing,
                    headers: {
                        "Content-Type": "text/html; charset=utf-8",
                    },
                };
            }
            const registerRes = await actions.register();
            if (registerRes) {
                this.upsertSigningKeyFromEnv(env);
                const { status, message } = await this.register(this.reqUrl(actions.url), (0, strings_1.stringifyUnknown)(env[consts_1.envKeys.DevServerUrl]), registerRes.deployId, getHeaders);
                return {
                    status,
                    body: (0, strings_1.stringify)({ message }),
                    headers: {
                        "Content-Type": "application/json",
                    },
                };
            }
        }
        catch (err) {
            return {
                status: 500,
                body: (0, strings_1.stringify)(Object.assign({ type: "internal" }, (0, errors_1.serializeError)(err))),
                headers: {
                    "Content-Type": "application/json",
                },
            };
        }
        return {
            status: 405,
            body: JSON.stringify({
                message: "No action found; request was likely not POST, PUT, or GET",
                isProd: this._isProd,
                skipDevServer: this._skipDevServer,
            }),
            headers: {},
        };
    }
    async runStep(functionId, stepId, data, timer) {
        var _a, _b;
        try {
            const fn = this.fns[functionId];
            if (!fn) {
                // TODO PrettyError
                throw new Error(`Could not find function with ID "${functionId}"`);
            }
            // TODO PrettyError on parse failure; serve handler may be set up badly
            const { event, steps, ctx } = zod_1.z
                .object({
                event: zod_1.z.object({}).passthrough(),
                /**
                 * When handling per-step errors, steps will need to be an object with
                 * either a `data` or an `error` key.
                 *
                 * For now, we support the current method of steps just being a map of
                 * step ID to step data.
                 *
                 * TODO When the executor does support per-step errors, we can uncomment
                 * the expected schema below.
                 */
                steps: zod_1.z
                    .record(zod_1.z.any().refine((v) => typeof v !== "undefined", {
                    message: "Values in steps must be defined",
                }))
                    .optional()
                    .nullable(),
                // steps: z.record(incomingOpSchema.passthrough()).optional().nullable(),
                ctx: zod_1.z
                    .object({
                    run_id: zod_1.z.string(),
                    stack: zod_1.z
                        .object({
                        stack: zod_1.z
                            .array(zod_1.z.string())
                            .nullable()
                            .transform((v) => (Array.isArray(v) ? v : [])),
                        current: zod_1.z.number(),
                    })
                        .passthrough()
                        .optional()
                        .nullable(),
                })
                    .optional()
                    .nullable(),
            })
                .parse(data);
            /**
             * TODO When the executor does support per-step errors, this map will need
             * to adjust to ensure we're not double-stacking the op inside `data`.
             */
            const opStack = (_b = (_a = ctx === null || ctx === void 0 ? void 0 : ctx.stack) === null || _a === void 0 ? void 0 : _a.stack.slice(0, ctx.stack.current).map((opId) => {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                const step = steps === null || steps === void 0 ? void 0 : steps[opId];
                if (typeof step === "undefined") {
                    // TODO PrettyError
                    throw new Error(`Could not find step with ID "${opId}"`);
                }
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                return { id: opId, data: step };
            })) !== null && _b !== void 0 ? _b : [];
            const ret = await fn.fn["runFn"]({ event, runId: ctx === null || ctx === void 0 ? void 0 : ctx.run_id }, opStack, 
            /**
             * TODO The executor is sending `"step"` as the step ID when it is not
             * wanting to run a specific step. This is not needed and we should
             * remove this on the executor side.
             */
            stepId === "step" ? null : stepId || null, timer, fn.onFailure);
            if (ret[0] === "complete") {
                return {
                    status: 200,
                    body: ret[1],
                };
            }
            /**
             * If the function has run user code and is intending to return an error,
             * interrupt this flow and instead throw a 500 to Inngest.
             *
             * The executor doesn't yet support per-step errors, so returning an
             * `error` key here would cause the executor to misunderstand what is
             * happening.
             *
             * TODO When the executor does support per-step errors, we can remove this
             * comment and check and functionality should resume as normal.
             */
            if (ret[0] === "run" && ret[1].error) {
                /**
                 * We throw the `data` here instead of the `error` because we expect
                 * `data` to be a prepared version of the error which may have been
                 * altered by middleware, whereas `error` is the initial triggering
                 * error.
                 */
                throw new errors_1.OutgoingResultError({
                    data: ret[1].data,
                    error: ret[1].error,
                });
            }
            return {
                status: 206,
                body: Array.isArray(ret[1]) ? ret[1] : [ret[1]],
            };
        }
        catch (unserializedErr) {
            /**
             * Always serialize the error before sending it back to Inngest. Errors,
             * by default, do not niceley serialize to JSON, so we use the a package
             * to do this.
             *
             * See {@link https://www.npmjs.com/package/serialize-error}
             */
            const isOutgoingOpError = unserializedErr instanceof errors_1.OutgoingResultError;
            let error;
            if (isOutgoingOpError) {
                error =
                    typeof unserializedErr.result.data === "string"
                        ? unserializedErr.result.data
                        : (0, strings_1.stringify)(unserializedErr.result.data);
            }
            else {
                error = (0, strings_1.stringify)((0, errors_1.serializeError)(unserializedErr));
            }
            const isNonRetriableError = isOutgoingOpError
                ? unserializedErr.result.error instanceof NonRetriableError_1.NonRetriableError
                : unserializedErr instanceof NonRetriableError_1.NonRetriableError;
            /**
             * If we've caught a non-retriable error, we'll return a 400 to Inngest
             * to indicate that the error is not transient and should not be retried.
             *
             * The errors caught here are caught from the main function as well as
             * inside individual steps, so this safely catches all areas.
             */
            return {
                status: isNonRetriableError ? 400 : 500,
                error,
            };
        }
    }
    configs(url) {
        return Object.values(this.rawFns).reduce((acc, fn) => [...acc, ...fn["getConfig"](url, this.name)], []);
    }
    /**
     * Return an Inngest serve endpoint URL given a potential `path` and `host`.
     *
     * Will automatically use the `serveHost` and `servePath` if they have been
     * set when registering.
     */
    reqUrl(url) {
        let ret = new URL(url);
        if (this.servePath)
            ret.pathname = this.servePath;
        if (this.serveHost)
            ret = new URL(ret.pathname + ret.search, this.serveHost);
        /**
         * Remove any introspection query strings.
         */
        ret.searchParams.delete(consts_1.queryKeys.Introspect);
        return ret;
    }
    registerBody(url) {
        const body = {
            url: url.href,
            deployType: "ping",
            framework: this.frameworkName,
            appName: this.name,
            functions: this.configs(url),
            sdk: `js:v${version_1.version}`,
            v: "0.1",
        };
        // Calculate the checksum of the body... without the checksum itself being included.
        body.hash = (0, hash_js_1.sha256)().update((0, canonicalize_1.default)(body)).digest("hex");
        return body;
    }
    async register(url, devServerHost, deployId, getHeaders) {
        const body = this.registerBody(url);
        let res;
        // Whenever we register, we check to see if the dev server is up.  This
        // is a noop and returns false in production.
        let registerURL = this.inngestRegisterUrl;
        if (!this._skipDevServer) {
            const hasDevServer = await (0, devserver_1.devServerAvailable)(devServerHost, this.fetch);
            if (hasDevServer) {
                registerURL = (0, devserver_1.devServerUrl)(devServerHost, "/fn/register");
            }
        }
        if (deployId) {
            registerURL.searchParams.set(consts_1.queryKeys.DeployId, deployId);
        }
        try {
            res = await this.fetch(registerURL.href, {
                method: "POST",
                body: (0, strings_1.stringify)(body),
                headers: Object.assign(Object.assign({}, getHeaders()), { Authorization: `Bearer ${this.hashedSigningKey}` }),
                redirect: "follow",
            });
        }
        catch (err) {
            this.log("error", err);
            return {
                status: 500,
                message: `Failed to register${err instanceof Error ? `; ${err.message}` : ""}`,
            };
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        let data = {};
        try {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            data = await res.json();
        }
        catch (err) {
            this.log("warn", "Couldn't unpack register response:", err);
        }
        const { status, error, skipped } = registerResSchema.parse(data);
        // The dev server polls this endpoint to register functions every few
        // seconds, but we only want to log that we've registered functions if
        // the function definitions change.  Therefore, we compare the body sent
        // during registration with the body of the current functions and refuse
        // to register if the functions are the same.
        if (!skipped) {
            this.log("debug", "registered inngest functions:", res.status, res.statusText, data);
        }
        return { status, message: error };
    }
    get isProd() {
        return this._isProd;
    }
    upsertSigningKeyFromEnv(env) {
        if (!this.signingKey && env[consts_1.envKeys.SigningKey]) {
            this.signingKey = String(env[consts_1.envKeys.SigningKey]);
        }
    }
    shouldShowLandingPage(strEnvVar) {
        var _a, _b;
        return (_b = (_a = this.showLandingPage) !== null && _a !== void 0 ? _a : (0, scalar_1.strBoolean)(strEnvVar)) !== null && _b !== void 0 ? _b : true;
    }
    validateSignature(sig, body) {
        // Never validate signatures in development.
        if (!this.isProd) {
            // In dev, warning users about signing keys ensures that it's considered
            if (!this.signingKey) {
                // TODO PrettyError
                console.warn("No signing key provided to validate signature. Find your dev keys at https://app.inngest.com/test/secrets");
            }
            return;
        }
        // If we're here, we're in production; lack of a signing key is an error.
        if (!this.signingKey) {
            // TODO PrettyError
            throw new Error(`No signing key found in client options or ${consts_1.envKeys.SigningKey} env var. Find your keys at https://app.inngest.com/secrets`);
        }
        // If we're here, we're in production; lack of a req signature is an error.
        if (!sig) {
            // TODO PrettyError
            throw new Error(`No ${consts_1.headerKeys.Signature} provided`);
        }
        // Validate the signature
        new RequestSignature(sig).verifySignature({
            body,
            allowExpiredSignatures: this.allowExpiredSignatures,
            signingKey: this.signingKey,
        });
    }
    signResponse() {
        return "";
    }
    /**
     * Log to stdout/stderr if the log level is set to include the given level.
     * The default log level is `"info"`.
     *
     * This is an abstraction over `console.log` and will try to use the correct
     * method for the given log level.  For example, `log("error", "foo")` will
     * call `console.error("foo")`.
     */
    log(level, ...args) {
        const logLevels = [
            "debug",
            "info",
            "warn",
            "error",
            "fatal",
            "silent",
        ];
        const logLevelSetting = logLevels.indexOf(this.logLevel);
        const currentLevel = logLevels.indexOf(level);
        if (currentLevel >= logLevelSetting) {
            let logger = console.log;
            if (Object.hasOwnProperty.call(console, level)) {
                logger = console[level];
            }
            logger(`inngest ${level}: `, ...args);
        }
    }
}
exports.InngestCommHandler = InngestCommHandler;
class RequestSignature {
    constructor(sig) {
        const params = new URLSearchParams(sig);
        this.timestamp = params.get("t") || "";
        this.signature = params.get("s") || "";
        if (!this.timestamp || !this.signature) {
            // TODO PrettyError
            throw new Error(`Invalid ${consts_1.headerKeys.Signature} provided`);
        }
    }
    hasExpired(allowExpiredSignatures) {
        if (allowExpiredSignatures) {
            return false;
        }
        const delta = Date.now() - new Date(parseInt(this.timestamp) * 1000).valueOf();
        return delta > 1000 * 60 * 5;
    }
    verifySignature({ body, signingKey, allowExpiredSignatures, }) {
        if (this.hasExpired(allowExpiredSignatures)) {
            // TODO PrettyError
            throw new Error("Signature has expired");
        }
        // Calculate the HMAC of the request body ourselves.
        // We make the assumption here that a stringified body is the same as the
        // raw bytes; it may be pertinent in the future to always parse, then
        // canonicalize the body to ensure it's consistent.
        const encoded = typeof body === "string" ? body : (0, canonicalize_1.default)(body);
        // Remove the /signkey-[test|prod]-/ prefix from our signing key to calculate the HMAC.
        const key = signingKey.replace(/signkey-\w+-/, "");
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any
        const mac = (0, hash_js_1.hmac)(hash_js_1.sha256, key)
            .update(encoded)
            .update(this.timestamp)
            .digest("hex");
        if (mac !== this.signature) {
            // TODO PrettyError
            throw new Error("Invalid signature");
        }
    }
}
//# sourceMappingURL=InngestCommHandler.js.map