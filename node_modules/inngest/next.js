"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serve = exports.name = void 0;
const InngestCommHandler_1 = require("./components/InngestCommHandler");
const consts_1 = require("./helpers/consts");
exports.name = "nextjs";
const isNextEdgeRequest = (req) => {
    var _a;
    return typeof ((_a = req === null || req === void 0 ? void 0 : req.headers) === null || _a === void 0 ? void 0 : _a.get) === "function";
};
/**
 * In Next.js, serve and register any declared functions with Inngest, making
 * them available to be triggered by events.
 *
 * @example Next.js <=12 can export the handler directly
 * ```ts
 * export default serve(inngest, [fn1, fn2]);
 * ```
 *
 * @example Next.js >=13 with the `app` dir must export individual methods
 * ```ts
 * export const { GET, POST, PUT } = serve(inngest, [fn1, fn2]);
 * ```
 *
 * @public
 */
const serve = (nameOrInngest, fns, opts) => {
    const handler = new InngestCommHandler_1.InngestCommHandler(exports.name, nameOrInngest, fns, opts, (reqMethod, req, _res) => {
        /**
         * `req.method`, though types say otherwise, is not available in Next.js
         * 13 {@link https://beta.nextjs.org/docs/routing/route-handlers Route Handlers}.
         *
         * Therefore, we must try to set the method ourselves where we know it.
         */
        const method = reqMethod || req.method;
        if (!method) {
            // TODO PrettyError
            throw new Error("No method found on request; check that your exports are correct.");
        }
        const isEdge = isNextEdgeRequest(req);
        let scheme = "https";
        try {
            // eslint-disable-next-line @inngest/process-warn
            if (process.env.NODE_ENV === "development") {
                scheme = "http";
            }
        }
        catch (err) {
            // no-op
        }
        const url = isEdge
            ? new URL(req.url)
            : new URL(req.url, `${scheme}://${req.headers.host || ""}`);
        const getQueryParam = (key) => {
            var _a, _b;
            return ((_b = (isEdge ? url.searchParams.get(key) : (_a = req.query[key]) === null || _a === void 0 ? void 0 : _a.toString())) !== null && _b !== void 0 ? _b : undefined);
        };
        const hasQueryParam = (key) => {
            var _a;
            return ((_a = (isEdge
                ? url.searchParams.has(key)
                : Object.hasOwnProperty.call(req.query, key))) !== null && _a !== void 0 ? _a : false);
        };
        const getHeader = (key) => {
            var _a, _b;
            return ((_b = (isEdge ? req.headers.get(key) : (_a = req.headers[key]) === null || _a === void 0 ? void 0 : _a.toString())) !== null && _b !== void 0 ? _b : undefined);
        };
        /**
         * Vercel Edge Functions do not allow dynamic access to environment
         * variables, so we'll manage `isProd` directly here.
         *
         * We try/catch to avoid situations where Next.js is being used in
         * environments where `process.env` is not accessible or polyfilled.
         */
        let isProduction;
        try {
            // eslint-disable-next-line @inngest/process-warn
            isProduction = process.env.NODE_ENV === "production";
        }
        catch (err) {
            // no-op
        }
        return {
            isProduction,
            url,
            register: () => {
                var _a;
                if (method === "PUT") {
                    return {
                        deployId: (_a = getQueryParam(consts_1.queryKeys.DeployId)) === null || _a === void 0 ? void 0 : _a.toString(),
                    };
                }
            },
            run: async () => {
                if (method === "POST") {
                    return {
                        data: isEdge
                            ? (await req.json())
                            : req.body,
                        fnId: getQueryParam(consts_1.queryKeys.FnId),
                        stepId: getQueryParam(consts_1.queryKeys.StepId),
                        signature: getHeader(consts_1.headerKeys.Signature),
                    };
                }
            },
            view: () => {
                if (method === "GET") {
                    return {
                        isIntrospection: hasQueryParam(consts_1.queryKeys.Introspect),
                    };
                }
            },
        };
    }, ({ body, headers, status }, _method, req, res) => {
        if (isNextEdgeRequest(req)) {
            return new Response(body, { status, headers });
        }
        for (const [key, value] of Object.entries(headers)) {
            res.setHeader(key, value);
        }
        res.status(status).send(body);
    }, ({ body, headers, status }) => {
        return new Response(body, { status, headers });
    });
    /**
     * Next.js 13 uses
     * {@link https://beta.nextjs.org/docs/routing/route-handlers Route Handlers}
     * to declare API routes instead of a generic catch-all method that was
     * available using the `pages/api` directory.
     *
     * This means that users must now export a function for each method supported
     * by the endpoint. For us, this means requiring a user explicitly exports
     * `GET`, `POST`, and `PUT` functions.
     *
     * Because of this, we'll add circular references to those property names of
     * the returned handler, meaning we can write some succinct code to export
     * them. Thanks, @goodoldneon.
     *
     * @example
     * ```ts
     * export const { GET, POST, PUT } = serve(...);
     * ```
     *
     * See {@link https://beta.nextjs.org/docs/routing/route-handlers}
     */
    const fn = handler.createHandler();
    return Object.defineProperties(fn.bind(null, undefined), {
        GET: { value: fn.bind(null, "GET") },
        POST: { value: fn.bind(null, "POST") },
        PUT: { value: fn.bind(null, "PUT") },
    });
};
exports.serve = serve;
//# sourceMappingURL=next.js.map